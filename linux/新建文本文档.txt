1.linux下查看监听端口的指令
	netstat指令:
		-a：显示所有连线中的socket
		-t：显示tcp传输协议的连线情况
		-u：显示udp传输协议的连线情况
		-l：显示监控（listen状态）中的服务器的socket
		-p：显示正在使用的socket程序的pid
		-n：直接使用ip地址
	比如：
		列出所有端口：netstat -a
		列出所有tcp端口：netstat -at
		列出所有udp端口：netstat -au
		列出所有属于监听状态的端口：netstat -l
		只列出所有监听tcp端口：netstat -lt
		只列出所有监听udp端口：netstat -lu
2.内存泄漏
	概念：程序申请的空间，在使用完之后未释放，一直占用着内存
	工具：
		valgrind：使用时会带来很多问题
		gdb：使用call命令调用系统函数来检查内存泄漏问题，效率不高，简单的内存泄漏
			call malloc_stats()；查看系统的内存信息
				在函数分配执行前在gdb中执行该命令，执行结束后，再执行一次，查看两次的system bytes和in use bytes是否相同，相同，则释放
				这样就确定了那个函数有内存泄漏
			call malloc_info(0,stdout)：在标准输出中显示结果（xml文件格式）
				关注rest：剩余了多少，通过函数执行前后的两次调用的比较，找到发生内存泄漏的函数位置
		matrace工具：
			1.添加头文件#include <mcheck.h>
			2.使用mtrace()和muntrace()两条语句将要检测的=内存泄漏的代码块包含起来，mtrace函数用来跟踪和分许后面的一切内存释放个分配的操作
			3.在终端定义一个环境变量，用来指示一个文件，输出log信息。export MALLOC_TRACE=mymeory.log，也可以在代码中setenv("MALLOC_TRACE",output,1);
			4.gcc运行程序(-g)
			5.使用mtrace工具分析log文件 $mtrace 二进制文件名 $MALLOC_TRACE	或者$mtrace output	
3.项目难点
	我在项目中对两部分内容进行了优化
		1.项目设计初期，是将所有的秘钥都放在了数据库当中，第三方进程在进行加密的时候，需要访问数据库，拿到秘钥进行加密，这个过程比较耗费资源，
		  后期的话，添加了共享内存模块，将当前客户端和服务器使用的秘钥放在共享内存中，提高了速率
		2.在设计服务器进程的时候，将他设计前台进程，后期经过优化，将服务器进程设计为一个守护进程，这就涉及到了如果关闭守护进程的问题，在linux中
		   虽然可以通过命令关闭，但这样就非常影响用户的体验感，另外，我们还希望服务器进程关闭之前能够释放掉已经开辟的资源，所以，我最终是通过编写了
		   一个简单的shell脚本，在shell脚本中，获取服务器进程的进程号，当通过kill函数向服务器该进程发送信号，服务器端注册信号捕捉函数，在信号处理函数中，
		  修改一个标志位的值，当标志位置1时，是的服务器进程跳出监听循环，释放内存，结束进程。
4.c++中new操作失败后返回什么
	1.抛出bad_alloc异常来报告分配失败，gcc编译器
	2.返回空指针，而不会抛出异常	
5.c++中不能用memset来初始化类对象，因为初始化类对象的时候，将类对象中包含的虚函数表的指针也清除了，这样一来，只要调用虚函数，程序就会崩溃
6.同步和异步的区别：
	同步：你给别人打电话，但对方占线，你就不停的打，知道打通为止，这样导致你其他的事情都干不了，而白白浪费了事件
	异步：当电话没打通的时候，你没有继续打，而是发了一条短信通知对方后去干别的事情了，当对方看见后，就回复你
	总之：同步就是我强依赖你，我必须等到答复，才能做出响应，如果没有收到恢复就一直处于等待状态，也就是阻塞状态，异步就是我并不强依赖你，我对你的响应时间不敏感，
	无论是否响应，我都可以继续执行，你响应了，我就做之前的事情，没响应就做其他事情，即我是非阻塞的。
7.http1.1和http1.0区别
	1.http1.1支持长连接，http1.0使用短连接，客户端和服务器每次请求都要建立tcp连接
	2.节约带宽
8.判断一个数是不是2的n次方
	if(num & (num-1) == 0) 则认为是
9.函数形参的入栈顺序为什么是从右王左
	1.这样的话，第一个参数的位置就在栈顶，我们很快就可以定位到第一个参数的位置,这样就可以定位后续的参数，	
	2.如果是从左往右压栈的话，最前面的参数就在栈底，除非知道参数个数，否则无法通过栈指针的相对位移求得最左边的参数，这样就变成了坐左边参数个数的不确定。
10 C语言free函数如何确定要释放多少内存空间
	malloc在分配内存的时候会根据参数指定的大小，分配一块空间，然后返回这块内存的起始位置给调用者，这就是调用者拿到的指针
	但这个指针并不是真正的起始位置，真正的指针在mallo返回指针的前面，用4个字节的空间存放分配的内存的大小信息
11.结构体为什么要对齐
	1.在32位或64位操作系统，数据总线时2位，地址总线也是32位，地址总线是32位，意味着寻址空间是按4递增的，数据总线时32位，意味着一次可以读4个字节，提高了cpu访问数据的效率，io操作很耗时
	2.不完全按照4字节对齐，主要是从节省内存角度考虑。
12.头文件的作用
	.h头文件中一般存放同名.c文件中定义的变量、数组、函数的声明。
	作用：
		1.方便开发：比如一个函数在多个程序中永达，就需要在多个文件中写上声明，一旦这个函数原型发生变化，我们就需要更新所有用到它的文件中的声明，这是很麻烦也很容易出错的
			    把声明写在头文件中，用到这个函数的文件就不用一一写它的声明了，只要包含头文件即可，要修改也很方便
		2.头文件可以定义所用的函数列表，方便查看你可以调用的函数
		3.头文件只是声明，不占内存空间。
13.select、poll、epoll
	总结：
		1.select、poll实现要自己不断轮询所用fd集合，直到设备就绪，
		  epoll其实也需要调用epoll_wait不断轮询就绪链表，
