1、变量的定义和声明的区别
2、bool、int、float、指针类型与零值比较的if语句
3、sizeof和strlen的区别
	1.sizeof是操作符，strlen是库函数
	2.sizeof的参数可以是数据类型、变量名，而strlen的参数只能是以‘\0’结尾的字符串
	3.sizeof和strlen的执行时间
	4.数组的在参数，strlen退化为指针
4、C语言关键字static和c++中关键字static有什么区别
	c：static用来修饰局部变量、全局变量
	c++：处上述功能外，static还可以定义成员变量和函数
5、C语言中malloc和c++中new有什么区别
	1.函数、操作符（可以重载）
	2.可以调用响应的构造和析构函数
6、两数比大小的标准宏
	#define MIN(X,Y)    ((x)<(y)?(x):(y))
8、a和&a的区别
9、简述c、c++程序编译的内存分配情况
	1.在全局数据区
		程序在编译时就已经分配好的，整个程序运行期间都存在，存放全局变量，静态变量
	2.在栈上
		执行函数时，函数内的局部变量都在栈上，栈不会出现内存泄漏、内存碎片问题
	3.在堆上：
		程序运行到malloc或new的时候，会在堆上分配空间，由程序员自己手动调用free或delete释放
	堆和栈的理论知识：
		申请方式：
		申请后的响应：
			栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常错误提示栈溢出。
			堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的
			       的空间分配给程序。
		申请大小的限制：
			栈：栈是向低地址扩展的数据结构，是一块连续的内存区域。即栈顶和栈的最大容量是系统预先设计好的。
			堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统使用链表来存储空间内存的地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。
		申请效率：
			栈：由操作系统自动分配，速度较快
			堆：new分配的内存，一般速度较慢，而且容易产生内存碎片和内存泄漏，不过用起来方便
		存储内容：
			栈：在函数调用时，第一个进栈的是主函数中函数调用语句的下一条可执行指令的地址，然后是函数的各个参数，这些参数是右右往左入栈的，然后是函数中的局部变量。
			       当函数调用结束后，局部变量先出栈，然后是形参，最后栈顶指针指向最开始存的地址，即主函数的下一条指令，程序有该店继续执行

10、简述strcpy、sprintf、memcpy的区别
	1.函数操作对象不同：字符串，源为任意类型，目的为字符串；两个都是可以任意操作的内存地址
	2.执行效率不同
	3.实现功能：字符串变量之间的拷贝、其他类型数据到字符串的转化，内存块之间的拷贝
11、设置地址为0x67a9的整形变量为0xaa66
12、面向对象的三大特征
13、c++空类有哪些成员函数
	默认构造函数、析构函数、拷贝构造函数、赋值操作符、取地址操作符
14.拷贝构造函数和赋值运算符
	1.拷贝构造函数是利用一个原有的类对象创建一个新的类对象，而复制运算符的对象是两个已经存在的对象
	2.拷贝构造函数的实现，不用判断源对象和新对象是否相同，而复制运算符需要判断两个对象是否相同，另外如果源对象内有内存分配，需要先把原有内存释放掉
17.类成员函数重写、重载区别
	1.范围的区别：重载的函数是在同一个类中，而重写是在两个类中针对虚函数而言
	2.参数的不同：重载的两个函数参数列表不同，而重写的两个函数参数列表相同
18.隐藏与重写、重载的不同
	函数隐藏：发生在基类和派生类中，函数完全相同（参数列表和函数名）时且基类没有虚函数，或者只是函数名相同，参数列表不同，无论是否有虚函数，都会发生隐藏
	1.范围的不同：隐藏函数和被隐藏函数不在同一个类中
	2.参数的不同：隐藏函数和被隐藏函数的参数列表可以相同也可以不同，但函数名肯定相同
		       当参数列表不同的时候，无论基类中的函数是否是虚函数，基类的函数都会被隐藏，而不是重写。
18、简述多态实现的原理
	1.c++的多态性是通过动态绑定技术实现的
	2.含有虚函数的类都有虚函数表
	3.当子类对父类的虚函数进行重写的时候，子类的续表指针保存的子类自己的虚函数，
	多态的三个条件：
		要有继承、虚函数重写、父类引用（指针）指向子类对象
19、链表和数组有什么区别
	1.存储方式：数组是一块连续的空间，声明时就要确定长度，链表是一块可不连续的动态空间，长度不固定，每个结点要保存相邻结点指针。
	2.数据查找：数组的线性查找速度快，查找操作可以直接使用偏移地址，链表需要按顺序检索结点，效率低
	3.数据插入和删除：链表可以快速的插入和删除节点，而数组则可能需要大量的数据移动
	4.越界问题：链表不存在越界，数组有越界问题
20、单链表反序
	方法一：
		struct  listnode * reverselist（struct listnode *head）
		{
			if（head == NULL || head->next == NULL）
			      return head；
			struct listhead *pre = NULL；
			struct listnode *curr = head；
			struct listnode *temp = NULL；
			while（curr）
			{
			          temp = curr->next；

			          curr->next = pre；
			          pre= curr；
			          curr = temp；
			}
			return pre；
		}
	方法二：迭代
		struct  listnode * reverselist（struct listnode *head）
		{
			if（head == NULL || head->next == NULL）
			      return head；
			struct listnode * newnode = reverselist（head->next）；
			head->next->next = head；
			head->next = null；
			return newnode；
		}
21、简述队列和栈的异同
	相同之处：
	1.他们都属于线性表。
	2.线性表的特点是数据元素之间存在“一对一”的关系，栈和队列都是操作受限制的线性表。
	3.都只能在线性表的端点插入和删除

	不同之处：
	栈（Stack）是只允许在表的尾端进行插入或删除，（在栈中就是“栈顶”），其最大的特点是“后进先出”，可以类比为弹夹中压子弹，最后压的子弹却是最先射出的。
	队列（Queue）是只允许在表尾进行插入数据，表头进行删除操作的线性表，其最大的特点是“先进先出”，就和我们在食堂打饭时排队一样，先打完的人先离开。

22、两个栈实现一个队列
	入队：直接将数据压入stack1中
	出栈：先判断Stack2是否为空，如果为空，则将stack1 的数据搬到Stack2
	          在判断stack2是否为空，如果Stack2仍为空，return -1，否则直接pop弹出stack2的栈顶元素
	假设采用链式栈：
		typedef struct node
		{
		       int data;
		       struct node *next;
		}Mystack;
		typedef struct stack
		{
		        struct Mystack *pTop;
		        int m_size;
		}Stack;
		void init_stack(Stack **pStack);
		void Push(Stack* pStack, int num);
		int Pop(Stack* pStack);
		it IsEmpty(Stack* pStack);   //1 空栈
	双栈实现队列：
		typedef struct queue
		{
		        int nCount；
		        Stack *pStack1;
		        Stack *pStack2;
		}Queue;
		void init_Queue(Queue **qQueue);
		void Push_Queue(Queue *qQueue,int num);
		int Pop_Queue(Queue *qQueue);
23、计算二叉树的深度
	方法一：深度优先搜索（DFS）（递归）
		int maxDepth（TreeNode *root）
		{
		      if（root == NULL）
			return 0；
		      return fmax（maxDepth（root->left），maxDepth（root->right））+1；
		}
	方法二：广度优先搜索（BFS） （迭代）
24、直接插入排序法
	void InsertSort（int arr[],int len）
	{
	       int i,j,temp;
	       for(i = 1; i < len; ++i)
	       {
		temp = arr[i];
		for(j = i; j > 0&&arr[j-1]>temp; j--)
		       arr[j] = arr[j-1];
		arr[j] = temp;
	       }
	}
25、冒泡排序法
	void bubble_Sort(int arr[],int len)
	{
	       int i,j,temp;
	       for(i = 0; i < len-1; ++i)
	       {
		for(j = 0 ; j < len - 1-i; ++j)
		{
		       if(arr[j] > arr[j +1])
		        {
			temp = arr[j];
			arr[j] = arr[j+1];
			arr[j + 1] = temp;
		        }
		}
	       }
	}
	优化：
	外层优化：在每次遍历的时候增加一个tag记录，如果发生狡猾，则tag=false，循环结束检测是否tag发生变化，未发生变化一定是排序完成
	void sort(int arr[],int len)
	{
		for(int i=0;i< len-1; ++i)
		{
			int flag = 0;
			for(j = 1; j < len - 1 - i; ++j)
			{
				if(arr[j] > arr[j + 1])
				{
					int temp = arr[j];
					arr[j + 1] = arr[j];
					arr[j] = temp;
					flag = 1;  //只要发生了交换，flag就置1
				}
			}
			if(flag == 0)
			{
				return ;
			}
		}
	}
	双向冒泡：一次下沉和一次上浮操作排序完成，虽然没有优化循环次数，但是减少了交换次数
	void sort(int arr[],int len)
	{
		int left = 0；
		int right = len;
		while(left < right)
		{
			for(int i = left; i <right; i++)    //从前往后下沉一个最大的数到末尾
			{
				if(arr[i] < arr[i - 1])
				{
					int num = arr[i-1];
					arr[i-1] = arr[i];
					arr[i] = num;
				}
			}
			right--;   //下沉一个之后，right--
			for(int i = right-1; i > left; i-- )
			{
				if(arr[i] < arr[i-1])
				{
					int num = arr[i-1];
					arr[i-1] = arr[i];
					arr[i] = num;
				}
			}
			left++;
		}
	}
26、选择排序法
	void select_sort(int arr[],int len)
	{		
	     int i,j,min,temp;
	     for(i = 0; i < len - 1; ++i)
	      {
		min = i;
		for(j = i+1;j < len; ++j)
		{
		      f(arr[j] < arr[min])
		        {
			min = j;
		        }
		}
		if(min != i)
		{
		      temp = arr[min];
		      arr[min] = arr[i];
		      arr[i] = temp;
		}
	      }
	}
27、堆排序
28、基数排序
29、谈谈对编程规范的认识
	程序的可行性，可读性、可移植性以及可测试性
30、short i = 0; i = i + 1；这两句有错吗
	第一句没有错
	第二句 1为int类型，将32位int转为16位short类型，会出现数据丢失的现象
31、&& 和&   ||和|的区别
	1、&和|是对操作数进行求值运算，而&&和||只是判断逻辑关系
	2、&&和||在只判断左侧操作数就能得到结果的情况下不再对右侧操作数求值
32、c++中引用和C语言的指针的区别
	1、引用必须被初始化，而指针可以在任何时候进行
	2、引用初始化后不能被改变，而指针可以随时改变指向
	3、引用不能为NULL，而指针可以
33、在二叉树中找出和为某一值的所有路径
	
35、typedef的define的区别
	1、用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏
	2、执行时间不同：typedef是编译过程的一部分，有类似检查的功能；define是宏定义，是预处理的部分，发生在编译之前，只是简单的进行字符串替换，不进行类型的检查
	3、作用域不同：typedef有作用域限定，define不受作用域约束，只要是在define声明后的引用都是正确的
			typedef：如果放在所有函数之外，它的作用域就是从它定义开始直到文件尾；
		                如果放在某个函数内，定义域就是从定义开始直到该函数结尾；
		define：不管是在某个函数内，还是在所有函数之外，作用域都是从定义开始直到整个文件结尾。
		不管是typedef还是define，其作用域都不会扩展到别的文件，即使是同一个程序的不同文件，也不能互相使用。
	4、对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。
		#define INT_D int*       INT_D a,b;  b 不是整形指针，而是整型数，因为define只是单纯的宏替换
		typedef int* int_p;        int_p c,d;
	5、typedef定义是语句，句尾要加分号，define不是语句，不加分号
36、关键字const是什么	
	const用来定义一个只读的变量或者对象。	
37、static有什么作用
	在C语言中static只要用于定义静态全局变量、静态局部变量、定义静态函数。在c++中新增了两个作用，定义静态数据成员和静态函数成员
	静态局部变量： 1.在编译阶段就已经分配空间，函数没有调用前它就已经存在
		        2.当离开了{}，static局部变量不会释放，只有程序结束static变量才会自动释放
		        3.static局部变量的作用域在当前的{}，，离开此{}不能使用
		        4.static局部变量不初始化，它的值为0
		        5.static局部变量初始化语句只执行一次，但可以赋值多次
		        6.static局部变量只能用常量初始化
	静态局部变量和普通局部变量的区别：
		        1.内存分配和释放：普通局部变量只有执行到变量定义语句才分配空间，离开作用域，自动释放空间
		        2.初始化
	普通全局变量：1.在函数外面定义的变量
		       2.若在使用变量时，在前面找不到此全局变量的定义，需要声明才能使用
		       3.全局变量不初始化，默认为0
  		       4.声明只针对全局变量
		       5.全局变量只能定义一次，但可以声明很多次
		       6.全局变量在编译阶段就已经分配好空间，整个程序运行结束才自动释放
	普通全局变量建议写法：
		        1.定义：建议初始化   int a=10；
		        2.声明：建议加extern    extern int a；
	静态全局变量：1.static全局变量和普通全局变量的区别就是作用域不同（文件作用域）
		       2、extern关键字只适用于普通全局变量
		       3.普通全局变量所有文件都能使用，前提是需要声明
		       4.static全局变量只能在本文件使用，别的文件不能使用
		       5.不同文件共同编译只能出现一个普通全局变量的定义
		       6.一个文件只能有一个static全局变量的定义，不同文件间的static全局变量，就算名字相同也是没有关系的2个static全局变量
	普通函数与static函数：
		       1.所有文件只能有一次普通函数的定义，一个文件可以由一个static函数的定义
		       2.普通函数所有文件都能使用，前提是需要声明，static函数只能在定义所在的文件中使用

38、extern有什么作用
	extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义
	extern修饰全局变量；
		1.变量定义：
		2.变量声明：
	extern修饰函数
		1.函数定义：
		2.函数声明：
	extern修饰符可用于C＋＋程序中调用c函数的规范问题。
  		比如在C＋＋中调用C库函数，就需要在C++程序中用extern "C"声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。
40、简述指针常量和常量指针的区别
	常量指针，是指一定了一个指针，指向一个只读常量
	指针常量，是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变
41、数组名和指针的区别

42、如何避免野指针
	野指针：随机指向内存中的一个地址，对于这个地址不一定有访问权，会导致内存泄漏（访问了已经释放的内存，或没有访问权限）。
	“野指针”产生原因及解决办法如下：
		（ 1） 指针变量没有被初始化。 解决办法：可以将指针变量初始化为NULL，或者具体的地址值。初始化为NULL的目的：一是出现段错误时易改错，二是(void *0) 是0地址，是不允许操作，不允许访问的。
		（ 2） 指针 p 被 free 或者 delete 之后， 没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向 NULL。
		（ 3） 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。
43、常引用有什么作用
	//普通引用  可以通过b修改a的值
	int  a = 10;
	int &b = a;   
	printf("b:%d \n", b);
 
	//常引用
	int  x = 20;
	const int &y = x;  //常引用 是 让变量 引用只读属性 不能通过y去修改x了
	//y = 21;      错误
	常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用
	于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。
44、字符串转数字
	num = (int)(pow(10,n-1-i));
	函数作用：1. 求10的n-1-i次方的值；
		 2. 将上方的值 强制转换成 int类型，即保留整数部分，将这个值赋值给num；
	int myatoi(const char *str)
	{
		char *p = str;
		int num = 0;
		int isNegative = 0;
		if(p == NULL)
		        return -1;
		if(*p == '-')
		{
		         isNegative = 1;
		         p++;
		}
		if(*p == '+')
		{
		        p++;
		}
		while(*p != '\0')
		{
		        num = num*10 + (*p - '0');
		        p++;
		        //int myatoi(const char *str)
	{
		char *temp = str;
		int num = 0,n = 0;
		int isNegative = 0;
		int n = 0;
		if(p == NULL)
		        return -1;
		while(*p++ != '\0')         //计算字符串长度
		        n++;
		p = str;
		if(*p == '-')
		{
		         isNegative = 1;
		         p++;
		}
		if(*p == '+')
		{
		        p++;
		}
		while(*p != '\0')
		{
		        num = num*10 + (*p - '0');        
		        p++;
		        //*p = *p - '0'; //将数字字符转换为数值
  		        //num += temp *(int)( pow(10 , n - 1 -i) );
		}
		if(isNegative == 0)
		        return num;
		if(isNegative == 1)
		        return 0-num;
	}
46、编码实现死循环
	while(1)  {}
47、编码实现某一变量某位清0或置1
	#define BIT3 (1<<3)
	置1：a |= BIT3
	清0：a &= ~BIT3
48、中断函数
49、构造函数能否为虚函数
	构造函数不能是虚函数，因为对象中的虚函数表助阵是在构造函数初始化阶段才初始化的，c++对象的构造分为两个阶段，首先分配一块内存，其次调用它的构造函数，这时如果它的构造函数是虚函数，
		那就要通过对象中的虚函数表指针来调用，而这个虚函数表指针是在构造函数初始化阶段才初始化的。
	析构函数可以是虚函数，
		因为此时虚函数表已经初始化好了，完全可以把析构函数放在虚函数表里面来调用
50、平衡二叉树
	判断条件
		1.是二叉排序树
			若左子树不为空，左子树上所有节点的值均小于它的根节点的值
			若右子树不为空，左子树上所有节点的值均大于它的根节点的值
			它的左右子树均为二叉排序树
		2.任何一个节点的左子树或者右子树都是平衡二叉树（左右高度差小于等于1）
51.linux操作系统的启动流程
	1. bios上电自检阶段：对基础硬件环境进行开机自检，比如cpu、内存、硬盘等，根据启动顺序进行启动
	2. MBR启动引导阶段：系统启动后，会从MBR（主引导程序）读取引导启动程序（bootloader）用于引导操作系统启动，当MBR加载到内存后，BIOS将控制权交给MBR
	3. 启动引导程序菜单（GRUB）	
	3. 加载内核阶段
	4. init初始化阶段
	