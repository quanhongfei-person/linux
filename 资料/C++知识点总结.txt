https://blog.csdn.net/weixin_45636889/article/details/115249194


怎么理解面向对象和面向过程
	面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；
	面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

	可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，
	面向过程的设计思路就是首先分析问题的步骤：
		1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。
	如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题，面向对象是以功能来划分问题，而不是步骤。
		整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。
		第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。
	同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。

6.c++中重载和覆盖的区别
	1.重载：在同一个类中，函数名相同，参数列表不同
	2.重写：子类重新定义父类中有相同名称参数的虚函数，主要是在继承关系中出现的。被重写的函数必须是虚函数
	3.重定义（隐藏）：子类重新定义父类中有相同名称的非虚函数，参数列表可以相同也可以不同，会覆盖其父类的方法，未体现多态
		如果派生类和基类的函数名相同，但是参数不同，此时，不管有没有virtual，基类的函数都会隐藏
		如果派生类和基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时，基类的函数被隐藏，如果有virtual就是重写了 

28.new与malloc的区别
	new和delete是c++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持
	new和detele在对象创建的时候自动执行构造函数，在对象销毁的时候自动执行析构函数
	new返回指定类型的指针，并可以自动计算出所需空间大小，malloc必须用户指定大小，并且默认返回void *，必须强制转换为实际类型指针

93.析构函数什么时候调用
	1.当在main里面声明了一个类A，那么~A会在main函数结束时调用
	2.如果在自定义的函数中声明A对象的话，函数调用结束的时候调用函数，
	3.delete指向A的指针的时候
	4.显式调用析构函数的时候
	作用：
		析构函数的作用不是删除对象，而是在撤销对象占用的内存之前完成的一些清理工作，使得这部分内存可以被程序分配给新对象使用
		
97.面向对象封装、继承、多态的作用
	封装：
		隐藏内部细节，对方提供公共的访问方式
		提供安全性，提高代码的复用性
	多态：
		不必编写每个子类的功能调用，可以直接把子类当做父类看，屏蔽子类间的差异，提高代码的通用率
		父类引用可以调用不同子类的功能，提高了代码的扩充性和可维护性
		
98.虚函数的作用
	虚函数是采用virtual修饰的函数
	主要作用是让成员函数一般化，用基类的指针指向不同的派生类的对象时，基类指针调用其虚成员函数，

4.c++中new操作失败后返回什么
	1.抛出bad_alloc异常来报告分配失败，gcc编译器
	2.返回空指针，而不会抛出异常	
5.c++中不能用memset来初始化类对象，因为初始化类对象的时候，将类对象中包含的虚函数表的指针也清除了，这样一来，只要调用虚函数，程序就会崩溃
	
		
		
	

		
	
		
	
		

		
	
	
		
	
		
	


