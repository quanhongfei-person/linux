服务器模型
	服务器模型大体分为三种：循环模型、并发模型及IO复用模型
	①循环模型：循环服务器指的是对客户端的请求和连接，服务器处理完一个之后再处理另一个，即串行处理客户端的请求。
		循环服务器又叫迭代服务器。循环服务器常用于UDP服务程序。	    
	②并发模式:
		多进程并发模式：如果没有客户端来建立连接，则会阻塞在accept函数处。
			一旦某个客户端连接建立起来，则立即开启一个新的进程来处理与这个客户的数据交互。
		多线程并发模型：在多进程并发模型中，每一个客户端连接开启fork一个进程，虽然linux中引入了写实拷贝机制，
			大大降低了fork一个子进程的消耗，但若客户端连接较大，则系统依然将不堪负重。
			通过多线程(或线程池)并发模型，可以在一定程度上改善这一问题。
	③IO多路复用模型（select poll epoll实现）：
		IO多路复用：实现一个进程可以监视多个文件句柄，多路指的是多个客户端网络连接，复用指的是同一个进程;
			一旦有个文件句柄就绪，就能通知应用程序执行响应的读写操作，
			没有读写等监听事件时，将会阻塞，让出CPU资源。
		实现：采用单线程通过select、poll、epoll等系统调用监控文件描述符，
		select：
			优点：跨平台
			缺点：1. 监听上限受文件描述符限制，默认最大为1024
			      2. 每次调用select，都需要把文件描述符集合从用户态拷贝到内核态，开销大
			      3. select是通过轮询所有的文件描述符，检测满足条件的fd，需要自己添加业务逻辑提高效率，编码难度提高
		poll：
			优点：1. 可以拓展监听上限，超出1024限制；
			      2. 自带数组结构，可以将监听事件与返回事件集合分离
			缺点：1. 每次调用poll，都需要把文件描述符集合从用户态拷贝到内核态，开销大
			      2. 检测满足条件的fd，需要自己添加业务逻辑提高效率，编码难度提高
				  3. 不能跨平台
		epoll：		
			优点：1. 突破文件描述符限制，
				  2. 自带红黑树结构，可以将监听事件与返回事件集合分离
				  3. 高效，不需要把文件描述符集合从用户态拷贝到内核态，开销小
			缺点：不支持跨平台
			
			水平触发：只要fd的接收缓冲区有数据，就会触发epoll_wait返回
			边沿触发：高效模式，只有由新的数据流入才会触发，无论缓冲区是否有数据，需配合非阻塞模式

select的缺点，epllo是怎么改进的
	select缺点：
		1.select支持的文件描述符数量收到限制，最大1024
		2.每次调用select，都需要把fd从内核态拷贝到用户态，开销大
		3.每次调用select，内核需要遍历传进来的所有fd，
	epoll解决方案：	
		1.epoll所监听的fd，不受限制文件描述符限制
		2.epoll的解决方案在于epoll_ctl函数，每次注册新的事件到epoll句柄中，会把所有的fd拷贝到内核，
			而不是在epoll_wait的时候重复拷贝，epoll保证每个fd整个过程只拷贝一次
		3.epoll只会对准备就绪的fd进行操作，而不是线性扫描所有fd的集合，这是因为内核实现中epoll是根据每个fd上面的回调函数实现的，
			只有就绪的fd才会调用回调函数，将就绪的fd加入就绪链表

如何将socket设置成非阻塞模式
	struct epoll_event event；
	event.events = EPOLLIN|EPOLLET
	int flag= fcntl(cfd, FD_GETFL);
	flag |= O_NONBLOCK;
	fcntl(cfd, FD_SETFL, flag)

如何设置socket的属性
	setsockopt(fd,level,optnamae,optval,optlen)设置socket属性
	比如：端口复用、接收超时、发送超时、缓冲区大小设置
	getsockop,获取socket属性

在建立socket之后为什么send和write都可以用，写到文件里的东西是怎么到网络通信的
	建立网络通信后，可以将socket对应的fd当做文件描述符使用，对应的send、write系统调用函数就都可以用了

HTTP、TCP、UDP的区别；
	HTTP:应用层协议，超文本传输协议
	    超文本：不仅包含文本，还包含图片、音频、视频、超链接等
	TCP：面向连接的、可靠的数据包传输。对于不稳定的网络层，采取完全弥补的通信方式，即丢包重传
		优点：稳定（数据流量、传输速度、数据传输顺序）
		缺点：传输速度慢、效率低、开销大
		使用场景：对数据完整性要求较高、不追求效率，比如：文件传输、大数据传输
	UDP：无连接的、不可靠的数据报传输。对于不稳定的网络层，采取完全不弥补的通信方式，默认还原网络状态
		优点：传输速度快、效率高、开销小
		缺点：不稳定（数据流量、速度、顺序）
		使用场景：对实时性要求较高的场合。稳定性其次。比如：视频电话、大型游戏
	区别总结：
		1.tcp是面向连接、保证可靠性的协议
		2.udp是无连接的，不能保证可靠性的连接
		3.tcp有超时重传、滑动窗口、确认和应答机制
		4.tcp是面向字节流的传输，不认为消息是一条一条的，数据包之间没有边界，会出现粘包问题，udp数据包是独立的，不会有粘包现象

简述TCP的三次握手、四次挥手的过程
	建立连接的过程：
		1）客户端发送一个带SYN标志的TCP报文到服务器，这是三次握手过程中的段1
		2）服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。
		3）客户必须再次回应服务器端一个ACK报文，这是报文段3。
	断开连接的过程：
		由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。
		收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
		1）客户端发出FIN位表示关闭连接的请求。
		2）服务器发出ACK,应答客户端的关闭连接请求。
		3）服务器发出FIN位，向客户端发送关闭连接请求。
		4）客户端发出ACK,应答服务器的关闭连接请求。
	建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，
	这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。

tcp3次握手而不是2次，为什么
	3次握手过程：
		服务器端新建套接字，绑定地址结构信后，开始监听，进入listen状态，
		客户端新建套接字后，调用conn函数发送连接请求SYN，并进入SYN_SEND状态，等待服务器确认
		服务器端一旦监听到有连接，会向客户端发送SYN和ACK应答，进入SYN_RCVD状态，
		客户端收到SYN+ACK后，发送ACK应答给服务器，并进入ESTABLISHED状态，开始读写数据，服务器收到ACK后，也进入ESTABLISHED状态，进行数据读写。	
	2次不安全，四次没必要
		tcp通信需要确认双方都具有数据收发能力，得到ACK响应则认为对方具有收发能力
		第一次握手是客户端发送SYN，服务器接收，服务器得出客户端发送能力、服务器端接收能力正常
		第二次握手服务器发syn+ack,客户端接收，客户端得出客户端发送、接受能力正常、服务器端的发送能力正常，但是此时服务器并不能确定客户端的接收能力是否正常
		第三次握手客户端客户端发送ack，服务器确认客户端的发送接收能力正常，服务器端自己的接收发送能力正常

3次握手可以携带数据吗

tcp的3次握手失败了，服务器端会如何处理
	失败原因有两种：
		1.服务器端没有收到SYN，则什么都不做
		2.服务器端回复了SYN+ACK，但一直没有收到ACK响应，则超时后就会发送RST重置连接报文，释放资源

4次挥手	
	客户端主动调用close函数，向服务器发送结束报文FIN，同时进入FIN_WAIT1状态
	服务器收到FIN后，服务器会返回确认报文ACK进入CLOSE_WAIT状态。如果此时服务器有数据要发送的话，客户端依然需要接收。客户端收到服务器的ACK应答，进入FIN_WAIT2状态，半连接
	服务器端数据发送完毕后，当服务器调用close关闭连接后时，会向客户端发送结束报文FIN，此时服务器进入LAST_ACKA状态，等待最后一个ACK的到来
	客户端收到服务器的结束报文，进入TIME_WAIT状态，并发送ACK给服务器，服务器收到后，立即进入CLOSED状态，而客户端要等待2msl时长，才会进入CLOSED状态

为什么不是三次而是四次
	由于TCP是全双工的，主动关闭方发送FIN请求不代表完全断开连接，只能表示主动关闭方不再发送数据了。而接收方可能还要发送数据，，就不能立即关闭服务器端到客户端的数据通道，
	所以就不能将服务器的FIN包给客户端的ACK包合并发送，只能先确认ACK，，等到服务器无需再发送数据包时再发送FIN包，所以需要四次
		
什么是滑动窗口
	滑动窗口通俗来讲就是一种流量控制技术
	它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，
	那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来。避免如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。

为什么是2MSL
		MSL指的是报文在网络中的最大生存时间，在客户端发送对服务器FIN包的确认包ACK后，这个ACK包会有可能到不了，服务器端如果没有接收到ACK，
		就会重传一个FIN包。所有客户端发送ACK需要留出2MSL的时间（ACK到达服务器时间 + 服务器重发FIN时间）等待确认服务器确实收到了ACK包，
		也就说客户端若2msl内没有收到服务器重传的fin，就认为服务器收到了客户端发送的ACK包

什么是半关闭
	当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。

什么是半连接队列
		服务器第一次收到客户端的SYN后，就会处于SYN_RCVD状态，此时双方还没有完全建立连接，服务器会把这种状态下的连接请求放在一个队列中，成为半连接队列。
		全连接队列，就是已经完成3次握手，建立起来连接的就会放在全连接队列
	
TIME_WAIT状态作用，为什么主动关闭方没有直接closed
		如果主动关闭连接方进入CLOSED状态，被动关闭方发送FIN包没有收到ACK确认，超时后就会重传一个FIN包。
		如果客户端没有TIME_WAIT状态直接进入CLOSE的状态释放资源，下次启动新的客户端就有可能使用了和之前客户端相同的地址信息有两个危害，
			第一个是这个刚启动的新客户端绑定地址成功后，就会收到一个重传的FIN包，对连接造成影响
			第二种是如果该客户端向相同服务器发送SYN连接请求，但此时服务器处于LAST_ACK状态，要求收到ACK而不是SYN，因此就会RST重置连接

2MSL存在的理由（maximu segment Lifetime最大报文生存时间30-60s，msl即单向传输tcp报文的最长时间）
	一定出现在主动关闭端，因为最后一个ack是主动方发送的
	1）让四次挥手关闭流程更加可靠	
		4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。
		若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。
	2）处理延迟的重复报文，这主要是为了避免前后两个使用相同连接中的前一个连接的报文到干扰后一个连接。

1台主机（服务器）大量出现TIME_WAIT的原因，如何处理
		TIME_WAIT是主动关闭连接方的一种状态，一台主机大量出现TIME_WAIT说明这台主机上发起了大量的主动关闭连接
		如果是客户端处于这种状态，问题不大，如果是服务器的话，则有问题
		解决办法：
			开启服务器套接字地址复用选项SO_REUSEADDR来通知内核，如果服务器端口忙，但tcp连接处于TIME_WAIT状态时，可以重用端口

1台主机大量出现CLOSE_WAIT的原因，如何处理
		CLOSE_WAIT是被动关闭连接方的一种状态，一台主机大量出现CLOSE_WAIT，有可能是被动方主句程序中忘了最后一步断开连接后调用close释放资源。
		解决办法：查代码

tcp管理中的保活机制（客户端出现故障怎么办）
		tcp通信中，若两端长时间没有数据往来，则每隔一段时间，服务器就会发送一个保活探测数据包，要求客户端进行回复，
		若连续多次没有收到响应，则认为已经断开，时长默认7200s，每隔一段时间默认75s，连续多次，默认9次，
	       
udp如何做可靠的连接，缺点，怎么解决这个问题
	1. 给数据包增加序号，保证单次通信的多个数据包之间有序
	2. 应用层增加校验机制，如接收方得到的校验码和发送方提供的校验码不一致，则丢弃该数据包请求重发
	3. 应用层增加确认机制，如果发送方没有在规定时间内收到应答方的应答包，则进行重发
	
粘包：
	什么是粘包：
		发送端为了将多个发送接收端的数据包，更加高效的发送给接收端，于是采用了优化算法，将多次间隔较小，数据量较小的数据，合并成
		一个数据量较大的数据包，然后进行封包。从接收缓冲区看，后一包的数据头紧接着前一包的数据尾。
	出现原因：
		发送方原因：优化算法可能造成粘包
		接收方原因：如果TCP接收数据包到缓存区的速度比应用程序从缓存中读取数据的速度快，多个数据包就会缓存，应用程序就可能读到一个首尾相接黏在一起的数据包
	什么时候需要处理：
		若多个数据包毫不相干，需要处理
	处理方法：
		1.发送方：关闭优化算法，使用TCP_NODELAY
		2.接收方：将问题交给应用层，通过循环处理，应用程序从缓存区读分组时，读完一条数据，就循环读取下一条，直至所有数据都被处理完
					
tcp、ip的帧格式
	ip协议：如果没有选项的话，ip首部20个字节
		4位版本号：IPV4、IPV6
		4位首部长度：ip header长度没有选项的话，一般为5（5*32bit=20字节）
		8位服务类型：一般没有使用
		16位总长度：ip报文总长度，ip首部+数据长度
		16位标识：每传送一个ip数据报，标识符加1，ip报文唯一的id，分片报文的id相同，便于进行重组
		3位标志：表明是否分片，R、DF、MF，目前只用后两位，DF为1，不分片，0分片；MF为1表示更多的片，为0表示这是最后一片
		13位片偏移：本分片的数据在原先数据报文中相对首位的偏移位，（需要乘以8才是原来的偏移）
		8位生存时间：TTL，IP报文所允许通过的路由器的最大数量
		8位协议：指出ip报文携带的数据使用的是哪种协议，ICMP：1，IGMP:2，TCP：6，UDP：17
		首部校验位：计算ip头部的校验和，检查报头的完整性
		源ip地址：表示ip数据报的源端设备
		目的ip地址：目的ip地址
		选项：
		数据：上层的报文，如TCP报文、UDP报文
	TCP协议：如果没有选项的话，tcp首部20个字节
		16位源端口号：标识一台计算机中唯一一个应用程序
		16位目的端口号
		32位序号：序号是本报文段发送的数据组的第一个字节的序号，每一个字节一个序号。比如一个报文段的序号为300，这个报文段数据部分有100个字节，则下一个报文段的序号为400
		32位确认序号：指明下一个期待收到的字节序号。确认号只有当ACK标志位为1时才有效
		4位首部长度：如果没有选项的话，就是20个字节，最多为1111（15）*4  = 60个字节
		保留6位：
		6个标志位：URG：紧急指针标志、ACK：确认序号标志、PSH：为1表示接收方收到数据后应尽快将该报文交给应用程序，而非在缓冲区排队、RST：重置连接标志、SYN：请求连接标志、FIN：断开连接标志
		16位窗口大小：用来告知发送端接收端的缓存大小，依次控制发送端发送数据的速率，从而达到流量控制
		16位校验和：奇偶校验，此校验和是对整个的TCP报文段，包括头部和数据，以16位字进行计算，接收端验证
		16位紧急指针：只有URG有效时，该指针才有效
		选项：
		数据：
	UDP协议：
		16位源端口号：
		16位端口号
		16位UDP长度：
		16位UDP校验和：
	以太网帧协议：首部14字节，尾部4字节
		6位目的MAC地址：
		6位源MAC地址：
		2位类型：0800（IP数据报），0806（ARP请求），0835（RARP请求）

http1.1和http1.0区别
	1.http1.1支持长连接，http1.0使用短连接，客户端和服务器每次请求都要建立tcp连接
	2.节约带宽

解释http报文格式
	http有两类报文：请求报文和应答报文
	http报文	
		http请求:请求行、请求头部、空行和请求数据组成
			请求头：由请求方法字段、URL字段和http协议版本字段组成，请求方法求GET、POST、HEAD、PUT、OPTION、TRACE、CONNECT
				常见的请求方法：GET，当客户端要从服务器中读取信息时，使用GET方法，请求指定页面信息
							POST：当客户端给服务器提供较多信息时，使用POST请求，数据被包含在请求体中，以名称和值的形式出现
							HEAD：类似于get请求，只不过返回的是响应中没有具体内容，用于获取报头
			请求头部：包含若干个属性，服务器据此得到客户端信息  格式：首部字段：值
			请求头部字段：
				host：请求资源所在服务器
				Accept：
				Accept-Charset：可接受的字符集
				Accept-Encode：可接受的内容编码
				connection：close，连接的管理，表示服务器发送完后就可释放连接；
			空行	
			响应体：服务器会给客户端的文本信息
									
		http响应：
			由状态行、响应头部、空行、响应体组成
			状态行：http协议版本、状态码、状态码的描述
			响应头部：
			空行	
			响应体：服务器会给客户端的文本信息
	
一次http请求所经历的步骤
	tcp建立三次连接后：web浏览器向web服务器发送请求命令
	web浏览器发送请求头
	web浏览器发送空行表示请求头发送结束
	应答：web服务器发送状态行，包括协议版本号、状态码
	web服务器发送响应头部信息，并发送空行后
	web服务器发送实际数据给浏览器
	web服务器关闭连接

15.访问百度的流程
	1.域名解析成ip地址
		在浏览器输入www.taobao，先看本机的缓存有没有域名记录，如果没有，找DSN服务器，返回一个ip地址
	2.与目的主机建立tcp三次连接
	3.http发送报文
		http协议分为：请求方法、URL地址、版本
		浏览器请求一个地址，应先按照应用层的http协议封装一个应用层的数据包，数据包就放了http请求报文，这个时候将http请求报文打包一个数据包，
		仅仅是数据包的数据部分，此时数据包是没有头的，根据http协议搞一个http请求报文，进行封装接着就是传输层，再次进行封装 ，确定服务器、客
		户端端口，在加上ip头，接着就是到数据链路层，走以太网协议，加上一个以太网数据包的头（mac）地址，如果超过1500个字节，则需要切割数据包，
		每个数据包都包含这些头，以及数据包序号，将数据包发送到路由器，，然后转发到别的子网的路由器，依次类推，就会被 跑到百度的某台服务器
	4.网站服务过程	
	5.http响应报文
		将数据包进行解封装，取出http数据包，读取数据包内容，做出响应，再把http响应成http报文，一样的过程，进行数据封装通过网关发送回去
	6与目的主句断开连接（4次挥手）

为什么视频电话使用udp？如何通过应用层解决UDP协议的不可靠性；tcp协议如何保证可靠性
	udp应用场景：实时性和效率高
		当应用程序对传输的可靠性要求不高，对传输速度和延迟性要求高时，使用udp协议，视频电话时，偶尔丢失一两个数据包不影响体验
		游戏开发（及时战略游戏）
		物联网（检测类传感器，频繁上报数据，做到节约资源）
	udp的可靠性：在应用层添加应答机制
		       在应用层添加超时重传机制
		       在应用层 滑动窗口机制
	sendto函数
		sendto函数不会进行数据分片，这里必须进行数据分包，一般保证udp的数据包的大小为1400/500字节
				MTU为46~1500字节，IP报头最小20字节，udp报头最下8字节，udp的数据包最大为1472，但容易出错，
	recvfrom函数：
		sendto      发送：1400字节->1400字节
		recvfrom  接收：1000字节->1000字节（每次都会丢掉400字节）
		总结：recvfrom每次都需要接收一个完整的报文，如果不接受完整，则剩余部分被丢弃
	    	          recv接收多少次都可以，因为TCP是一个字节流传输
	举例：客户端要传输6452字节数据给服务器
		1.需要进行分片传输，每片的数据位1400字节，最后一个分片为912字节
		2.需要对分片进行编码   

数据包的分片和重组
	数据包的分片：源主机和中间的路由器
		1.在TCP/IP分层中数据链路层用MTU来限制所能传输的数据包的大小。MTU是指一次传送的数据最大长度，不包括数据链层数据帧的帧头，当发送的ip数据报的大小超过了MTU时，
	  	 ip层就需要对数据进程分片，否则无法发送成功。
		2.ip分片发生在ip层，不仅源主机会进行分片，中间的路由器也有可能会进行分片，因为不同的网络的MTU是不一样的。如果传输路径上的某个网络的MTU比源网络的要小，路由器就
		   可能对ip数据报再次进行分片。而分片数据的重组只会发生在目的端的ip层
		3.ip层是没有超时重传机制的。如果ip层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层重传结果所有的分片都要重传一遍，这个代价有点大。由此可见，ip分片会
		   大大降低传输层传输数据的成功率，所有要尽量避免ip分片。
	数据包的重组：目的主机
		目的主机收到所有分片后，对分片依次进行重新组装还原的过程叫做ip数据包重组
		ip协议规定，只有最终的目的主句才能对分片进行重组
	
长链接和短连接，有什么区别？
	短连接：在http1.0版本的时候，客户端与服务器完成一个请求和响应之后，会将之前的TCP连接断开，下次请求的时候又重新建立TCP连接
	长连接：在http1.1版本后带来一个新功能，在客户端与服务器完成一次请求和响应之后，允许不断开TCP连接，这意味着下次请求就直接使用这个TCP连接而不再重新建立TCP连接
	note：长连接指的是一次TCP连接允许多次HTTP会话，HTTP永远都是一次请求和响应，会话结束，HTTP本身不存在长连接之说
	           http请求的头部信息中：Connection：keep-alive表示服务器和客户端建立长连接
	长连接优缺点：
		优点：当网站中有大量资源就开启长连接
		缺点：当客户端请求一次之后不再请求，而服务器却开着长连接资源被占用，这样严重的浪费资源

CS模型和BS模型，他们的区别？
	cs优点：
		cs架构的界面和操作可以很丰富
		安全性能很容易保证
		响应速度快
	cs缺点：
		维护成本高
		用户群固定，程序需要安装才可以使用
	bs优点
		具有分布式特点，可以随时进行查询、浏览等业务
		业务扩展简单，增加网页即可增加服务器功能
		维护简单方便
		开发简单，共享性强
	缺点：
		速度和安全性

ftp和tftp
	ftp协议：文件传出协议（TCP）
		ftp使用两个端口，21（服务器的命令端口）  20是（主动模式的数据连接）
			两个TCP连接，一个是控制层面的连接，一个是数据层面的连接
		主动模式：第二信道的tcp连接由服务器主动发起
			1.客户端主动找服务器建立第一信道，服务器的端口为21
			2.客户端给服务器发送一个数据包（port命令），告诉服务器客户端的地址结构信息-------A B C D E F（ABCD为客户端ip地址，E*256+F为客户端端口号）
			3.服务器主动发起第二信道的tcp连接

		被动模式：第二信道的tcp连接由客户端主动发起
			1.客户端主动找服务器建立第一信道，服务器的端口为21
			2.服务器给客户端发送一个数据包（pasv命令）-------A B C D E F（ABCD为服务器ip地址，E*256+F为服务器端口号）
			3.客户端主动发起第二信道的tcp连接
		常用命令：
			登录ftp服务器：ftp ip(服务器)  然后输入用户名和 密码
			查看ftp服务器上的文件：dir：显示服务器目录和文件列表
				  	      ls：显示服务器目录和文件列表
					      cd：进入服务器指定目录
					     lcd：进入本地客户端指定的目录
			下载文件：传输方式有二进制和ascii两种
				type：查看当前文件传输方式
				ascii：设定文件传输方式为ascii
				binary：设定文件传输方式为二进制方式
				get/recv：下载单个文件 get filename [newname]（filename为服务器上的文件名，newname为保存在本地的文件名）
				mget：下载多个文件
			长传文件：
				put/send：长传单个文件put filename [newname]（filename为本地的文件名，newname为服务器的文件名）
				mput：上传多个文件
			结束并退出
				bye：结合和服务器的ftp并推出ftp环境
			其他命令：
				pwd：查看ftp服务器的当前工作目录
				passive：主动和被动模式切换
				delete filename：删除服务器上一个文件
				mdelete：删除多个文件
				mkdir：在服务器上创建目录
	tftp：简单文件传输协议（UDP）
		tftp的服务器端口号69，仅支持文件上传和下载功能，支持丢包重传
		tftp传输是由客户端发起：
			文件下载：客户端发送读请求给服务器作为开始
				服务器发送数据报文（块编号1）给客户端 ，每次传输512字节
				客户端发送确认报文（ACK=1）给服务器
				。。。。。。。
				最后一次传输小于512字节，说明传输终止
			文件上传：客户端发送写请求给服务器
				服务器发送确认报文（ACK=0）给客户端   
				客户端发送数据报文（块编号1）给服务器
				服务器发送确认报文（ACK=1）给客户端
	
ARP协议
	简单地来说，ARP协议就是地址解析协议。通过目的ip地址而获取目的mac地址的过程
	①网络设备在什么情况下会发送ARP request？
		源设备在发送数据给目的设备前，会首先查看自身的ARP缓存，查找ARP缓存中是否存在目的设备的IP地址和MAC地址的映射。
		如果存在则直接使用，如果不存在则会发送ARP request。
	②每一台主机都设有一个ARP高速缓存（ARP cache）。里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。那么主机怎样知道这些地址呢？
		当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址，如果有，就在ARP高速缓存中查出其对应的硬件地址，
		再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。
		也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能主机A刚刚加电，其高速缓存还是空的，在这种情况下，主机A就自动运行ARP，
		然后按下面的步骤找出主机B的硬件地址。
		    1） ARP进程在本局域网上广播发送一个ARP请求分组。
	   	    2） 在本局域网 上的所有主机上运行的ARP进程都收到此ARP请求分组。
 		    3） 主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址。
		    4）主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。
		    ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间（如，10~20分钟）。凡超过生存时间的项目就从高速缓存中删除掉。
	③ARP请求时解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题，如果所要找的主机和源主机不在同一个局域网上，看上图有H1的那个图，主机H1就无法解析出另一个局域网上主机H2的硬件地址。
	   主机H1发送给H2数据报首先需要通过与主机H1连接在同一个局域网上的路由器R1来转发。因此主机H1这时需要把路由器R1的IP地址IP3解析为硬件地址HA3，以便能够把IP数据报传送到路由器R1，以后，
	   R1从转发表找到下一跳路由器R2，同时使用ARP解析出R2的硬件地址HA5。于是IP数据报按照硬件地址HAA5转发到路由器R2。路由器R2转发这个IP数据报时用类似方法解析出目的主机H2的硬件地址HA2，使IP数据报最终交付给主机H2。
		1） 发送方是主机（如H1），要把 IP 数据报发送到本网络上的另一个主机（如H2）。这时H1发送 ARP 请求分组（在网1上广播），找到目的主机H2的硬件地址。 
		2） 发送方是主机（如H1），要把 IP 数据报发送到另一个网络上的一个主机（如H3或H4）。这时H1发送 ARP请求分组（在网1上广播）， 找到网1上的一个路由器R1的硬件地址。剩下的工作由这个路由器R1来完成。R1要做的事情是下面的（3）（4） 
		3） 发送方是路由器（如R1），要把 IP 数据报转发到与R1连接在同一个网络（网2）上的一个主机（如H3）。这时R1发送ARP请求分组（在网2上广播）， 找到目的主机H3的硬件地址。 
		4） 发送方是路由器（如R2），要把 IP 数据报转发到网3上的一个主机（如H4）。H4与R1不是连接在同一个网络上，这时R1发送ARP请求分组（在网2上广播），找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成。

	有了ip地址为什么还需要arp协议
		arp协议工作在局域网内部那一层面
		1.ip地址是逻辑地址寻址，工作在网络层，具有全网范围内的寻址能力，可以快速定位目标地址所在的网络
		2.mac地址是物理地址寻址，工作在数据链路层，要将数据包发送给对方必须知道对方的mac地址，因为主机的以太网网卡只能识别mac地址


路由器和交换机 集线器
	集线器：
		定义：将网线集结起来的作用，实现最初级的网络互通，集线器是通过网线直接传送数据的，我们说他工作在物理层
		集线器的问题：由于集线器和每台设备都相连，他不能分辨出信息时给谁发送的，只能广泛的广播出去，A在发消息给C的时候，其他主机不能发消息，否则信息间会产生碰撞，引发错误，我们称各设备处于同一冲突域
	交换机：
		定义：根据网口的mac地址传送信息，这比网线直接传送多了一个步骤，即交换机工作在数据链路层，交换机解决了冲突问题，实现了任意两台电脑之间的互联，
	路由器：
		是互联网的枢纽，是连接英特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送数据。
		作用在OSI模型的第三层，提供了路由与转发两种重要机制
		路由：路由器控制层面的工作，决定数据包从来源端到目的端所经过的路由路径
		转发：路由器数据层面的工作，将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行）
		路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。也就是说，将路由器某个输入端口收到的分组，
		         按照分组要去的目的地，把该分组从路由器的某个合适的输出端口转发给下一跳的路由器。下一跳的路由器也按照这种方法处理分组，直到该分组到达终点为止。
	区别：
		1）工作层次不同：最初的交换机工作在OSI开放式系统互联模型的数据链路层，也就是第二层，而路由器则工作在OSI模型的网络层，就是第三层。
		2）数据的转发对象不同：交换机是根据MAC地址转发数据帧，而路由器则是根据IP地址来转发IP数据报/分组。数据帧是在IP数据包/分组的基础上封装了帧头（源MAC和目的MAC等）和帧尾（CRC校验码）。
		3）”分工“不同：交换机主要是用于组建局域网，而路由器则是负责让主机连接外网。
		4）冲突域和广播域：交换机分割冲突域，但是不分割广播域，而路由器分割广播域。
			冲突域是基于第一层（物理层）
			广播域是基于第二层（数据链路层）
	集线器;
	
单播、广播和组播
	单播：
		主机之间一对一的通讯模式，网络中的交换机或路由器只转发数据，不复制。网络中的交换机或路由器根据目标地址选择传输路径，若10个客户机需要相同的数据，则服务器需要逐一发送，重复10次相同的工作
		举例：收发邮件
	组播：
		主机之间一对一组的通讯模式，即加入了同一个组的主机之  间可以接收到此组内的所有数据，网络中的交换机或路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的
		交换机或路由器有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机，这样可以一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯
		举例：视频会议
	广播：
		主机之间一对所有的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以收到所有信息（无论是否需要），不用路径选择。
		举例：有线电视

wireshark抓包工具
	界面：
		1.display filter显示过滤器
			1.协议过滤：比如TCP、ip
			2.IP过滤：比如ip.src == 192.168.1.102 or ip.dst == 192.168.1.102
			3.端口过滤：tcp.port == 80   tcp.srcport == 80 
			4.http过滤：http.request.method == "GET"
			5.逻辑运算符and or
		2.packet list pane：封包列表
			编号、事件戳、原地址、目标地址、协议、长度、封包信息
		3.packet details pane：封包详细信息，
		4.dissector pane：16进制数据
		5.miscellanous：地址栏（杂项）

DNS（domain name system域名系统）原理
	DNS是因特网使用的命名系统，用来把人们使用的机器名字转化为ip地址
	用户与因特网上某台主机通信时，显然不愿意使用难记复杂的32位ip地址，大家更愿意使用容易记忆的主机名字。但是机器在处理ip数据报时，并不是使用域名，而是ip地址，因为域名长度不固定，处理起来比较麻烦
	因特网规模庞大，采用的是层次树状结构的命名方法，并使用分布式域名系统DNS，采用客户端服务器方式。DNS使大多数名字都在本地解析，少量解析需要在因特网通信。
	域名到ip地址的解析是由分布在因特网上的许多域名服务器共同完成的。域名服务器程序在专设的节点上运行，而人们也常把运行域名服务器程序成为域名服务器
	域名到ip的解析要点：当一个应用需要把主机名解析为ip地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把等待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器，本地域名服务器查找域名后，把对应ip地址放在
		应答报文中返回。应用程序获得ip地址后即可通信。若本地域名服务器不能应答该请求，则此域名服务器就暂时称为DNS的另一个客户，并向其他域名服务器发出查询请求。这个过程知道找到能够回答该请求的域名服务器位置。
	域名结构：
		任何一个在因特网上的主机或路由器都有域名，每一个域名都是由标点和序列组成，各标点之间用.隔开，比如mail.cctv.com，其中com是顶级域名，cctv是二级域名，mail是三级域名
	域名服务器分类：
		根域名服务器：所有的根域名服务器都知道所有的顶级域名服务器的域名和ip
		顶级域名服务器：管理在该顶级域名服务器下注册的二级域名域名
		权限域名服务器：
		本地域名服务器：
	域名解析过程：
		1.主机向本地域名服务器的查询一般都是递归查询。即如果主机所查询的本地域名服务器不知道被查询的域名的ip地址，那么本地域名服务器就以DNS客户端的身份继续发出查询请求报文（即替主机查询），
		   而不是让主机自己进行下一步查询。
		2.本地域名服务器向根域名服务器的查询是迭代查询，即当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出ip地址，要么告诉本地域名服务器下一步应该向哪一个域名服务器进行查询，
	 	   然后让本地域名服务器进行后续查询。

https原理介绍
	https = http + ssh
	http风险：
		被窃听的风险：第三方可以截获并查看你的内容
		被篡改的风险：第三方可以截获并修改你的内容
		被冒充的风险：第三方可以伪装成通信方与你通信
	ssh加密认证过程：
		非对称加密：公钥和私钥，公钥是公开的，所有人都知道，用公钥进行加密，私钥是保密的，只有持有者知道，用私钥进行解密，通过公钥加密的内容，只有通过私钥解开
		bob和它的朋友pat、susan、doug
			1.bob弄到两把钥匙：公钥和私钥
			2.私钥自己保留，公钥复制成3分，给它的朋友
			3.sunsan和bob讨论问题，susan先把自己的内容（明文）用公钥加密，然后把加密的内容传给bob。bob收到后，用私钥解开即可
			4.bob给susan回信。为防止内容被篡改，它先对新的内容用hash算法做一次处理，得到一个字符串哈希值，又用自己的私钥对哈希值加密得到一个签名，然后把签名和信（明文）一起给susan
			5.Susan收到信后，先用bob给的公钥对签名进行解密，得到哈希值A，然后Susan用了同样的哈希算法对信的内容进行一次哈希处理，得到另一个哈希值B，若A和B相等，，则确认信是bob写的，且没有被篡改
			6.bob通过网络把公钥发送给Doug，但是Jerry截获了公钥，并伪装成bob与Doug通信；
			7.bob发现自己的公钥被截获，为避免公钥被截获，它去第三方权威机构“证书中心”做认证，证书中心用自己的公钥对bob的公钥和其他信息做了一次加密，这样bob通过网络将数字证书传递给它的朋友后，
			小伙伴们先用认证中心的 公钥解密证书，这就就可以获得bob安全的公钥了
	https通信过程：
		1.浏览器发往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法
		2.服务器收到请求，选择浏览器支持的加密算法和哈希算法
		3.服务器将数字证书返回给浏览器，这里的数字证书可以是向某个机构申请的，也可以是自制的
		4.浏览器进入数字机构认证环节，这一部分是浏览器内置的TLS完成的
			4.1首先浏览器会从内置的证书列表索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书不是由权威机构颁发，是不可信任的，如果查到了对应的机构，则取出该机构颁发的公钥。
			4.2用机构证书公钥解密证书的内容和签名内容报告网站的网址、网站的公钥、证书的有效日期等，浏览器会先验证证书签名的合法性，认证通过后，浏览器就可以使用证书中的网站公钥了
		5.浏览器生成一个随机数R，即秘钥R，并使用公钥对随机数进行加密
		6.服务器用自己的私钥进行解密，得到R
		7.服务器以R为秘钥使用了对称秘钥算法加密网页内容并传送给浏览器
		8.浏览器以R为秘钥使用之前约定好的解密算法获取网页内容。
	note：前5步其实是https的握手过程，主要验证了服务端证书（内置公钥）的合法性，这个过程用到了一次非对称加密算法，主要是用来保护客户端生成的用于对称加密的随机数私钥。后续内容都是通过一开始约定好的对称加密算法进行的

1.linux下查看监听端口的指令
	netstat指令:
		-a：显示所有连线中的socket
		-t：显示tcp传输协议的连线情况
		-u：显示udp传输协议的连线情况
		-l：显示监控（listen状态）中的服务器的socket
		-p：显示正在使用的socket程序的pid
		-n：直接使用ip地址
	比如：
		列出所有端口：netstat -a
		列出所有tcp端口：netstat -at
		列出所有udp端口：netstat -au
		列出所有属于监听状态的端口：netstat -l
		只列出所有监听tcp端口：netstat -lt
		只列出所有监听udp端口：netstat -lu		
		
		
		
		
	

		
	
		
	
		

		
	
	
		
	
		
	


