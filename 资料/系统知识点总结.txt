sizeof和strlen的区别
	1.sizeof是操作符，strlen是库函数，因此执行时间不同，操作符在预处理时，函数在执行时
	2.sizeof的参数可以是数据类型、变量名，而strlen的参数只能是以‘\0’结尾的字符串或字符指针
	
指针的优点
	1.可以提高程序的编译效率和执行速度，使程序更加简洁
	2.通过指针可以直接操作内存地址

野指针、空指针
	空指针：空指针不指向任何实际的对象或函数，NULL是一个标准规定的宏定义，用来表示空指针常量
	野指针：就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的)指针变量在定义时如果未初始化，其值是随机的，指针变量的值是别的变量的地址，意味着指针指向了一个地址是不确定的变量，此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。
	野指针产生原因：指针变量未初始化;
					指针free或delete后没有设置为null，让人误以为是合法指针；导致指针操作越界
	
内存碎片内存泄露
	内存泄露(memory leak)：调用malloc函数申请内存，在程序结束前没有进行内存释放，造成内存泄漏;
	内存溢出(out of memory/ OOM):是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
	
C语言free函数如何确定要释放多少内存空间
	malloc在分配内存的时候会根据参数指定的大小，分配一块空间，然后返回这块内存的起始位置给调用者，这就是调用者拿到的指针
	但这个指针并不是真正的起始位置，真正的指针在mallo返回指针的前面，用4个字节的空间存放分配的内存的大小信息及起始地址

内存申请及销毁原理
	因为堆上分配的空间都有一个表头，存储了被分配内存的大小和起始地址，malloc函数只有在申请内存失败，才会返回null，
	malloc(0)认为我们申请内存成功，返回的是一个正常的地址，也就是说操作系统实际分配了内存空间，但可用内存空间为0，即返回的指针不能用;	

内存泄漏
	概念：程序申请的空间，在使用完之后未释放，一直占用着内存
	工具：
		valgrind：使用时会带来很多问题 (主要是memcheck， 可以检测到未初始化的内存及泄漏)
		用法：valgrind a.out
		gdb：使用call命令调用系统函数来检查内存泄漏问题，效率不高，简单的内存泄漏
			call malloc_stats()；查看系统的内存信息
				在函数分配执行前在gdb中执行该命令，执行结束后，再执行一次，查看两次的system bytes和in use bytes是否相同，相同，则释放
				这样就确定了那个函数有内存泄漏
			call malloc_info(0,stdout)：在标准输出中显示结果（xml文件格式）
				关注rest：剩余了多少，通过函数执行前后的两次调用的比较，找到发生内存泄漏的函数位置
		matrace工具：
			1.添加头文件#include <mcheck.h>
			2.使用mtrace()和muntrace()两条语句将要检测的=内存泄漏的代码块包含起来，mtrace函数用来跟踪和分许后面的一切内存释放个分配的操作
			3.在终端定义一个环境变量，用来指示一个文件，输出log信息。export MALLOC_TRACE=mymeory.log，也可以在代码中setenv("MALLOC_TRACE",output,1);
			4.gcc运行程序(-g)
			5.使用mtrace工具分析log文件 $mtrace 二进制文件名 $MALLOC_TRACE	或者$mtrace output	

宏中使用do{}while(0)的作用
	使用do{}while(0)构造的宏定义不会受到大括号、分号等影响，总是按照期望的方式执行
	1.辅助定义复杂的宏，避免引用的时候出错
	2.避免空的宏引起的警告

typedef void (*pfunc_t)(int data);   
	一般是给函数定义别名，pfunc_t是一个函数指针，函数类型是：void (*func)(int data);
	
回调函数定义：
	函数指针的调用，即是一个通过函数指针调用的函数，当把函数指针作为参数传递给另一个函数，当这个指针被用来调用其所指的函数时，就说这是回调函数
	作用：
		回调函数可以把调用者和被调用者分开，调用者不管谁是被调用者，它是只知道，一个具有某种特定原型、某些限制条件的被调用函数。

函数的递归调用
	递归就是调用一个函数的过程中直接或间接调用了自身，
	函数递归调用的要素：
		递归公式
		结束条件(堆栈溢出)
		
arr[2][3]
	arr[1]：表示一个一维数组，包含3个元素，即第1行元素首地址

预处理中#error作用
	编译程序时，只有遇到#error就会跳出一个编译错误，并输出用户自定义的错误信息，其目的是保证程序是按照你所想的那样编译的

extern C的作用
	在c++程序中调用C的的代码

临界资源：
	临界资源：一次仅允许一个进程访问的共享资源
	临界区：每个进程中访问临界资源的那段代码称为临界区
	临界区管理准则：一次只允许一个进程进入临界区
			         进入临界区的进程要在有限时间内退出
堆和栈的区别：
	1.申请方式
		栈空间用户无需申请，
		堆空间需要用户自己申请维护释放
	2.申请效率
		栈由系统自动分配，速度较快，
		堆是自己手动申请，速度慢，容易产生内存碎片
	3.存储内容：
		栈：函数调用时，产生的局部变量， 
		堆：自定义
	4.申请大小：
		栈是向低地址扩展的数据结构，是一块连续的内存空间，栈的最大容量是预先规定好的
		堆是向高地址扩展的数据结构，，是不连续的内存区域，

fscanf和fprintf
	格式化的输入、输出（对文件流指针操作）
	fsacnf(文件流指针，格式串，输入变量列表)    
	功能：从文件指针对应的文件读取数据，按照格式串的格式，传递给输入变量列表中的变量
	fprintf(文件流指针，格式串，输出变量列表)
	功能：按照格式串的格式，把输出变量列表中的变量，输出到文件指针对应的文件

volitile关键字
	系统对于访问频繁的变量，会将变量值放入寄存器以加快访问效率，而用volitile关键字修饰变量，就是告诉编译器不要对这个变量进行优化操作，
	也就是每次使用这个变量的时候都要去访问这个变量所在的内存地址空间，而不是访问这个变量所构建的一个寄存器，在使用这样一个变量的时候，
	他可能同时被好几个中断或者线程访问，用这样的一个变量可以保证我们获取这个变量值的实时性

strpcy 和strncpy比较
	strcpy缺陷：
		1.潜在内存越界问题（dest<src的长度）
		2.字符串结束标志丢失问题
	strncpy问题：
		1.无法解决内存覆盖问题
		2.效率低：当count>src的长度时，会继续拷贝‘\0’直到count的长度
	strncpy更安全，strcpy无法控制拷贝的长度，不小心就会出现dest的大小无法容纳src的情况，就会出现越界的问题，程序就会崩溃。
	而strncpy就控制了拷贝的字符数避免了这类问题，但是要注意的是dest依然要注意要有足够的空间存放src，而且src 和 dest 所指的内存区域不能重叠。		

左值和右值
	左值(locationable 可定位)：内存中占有确定位置的对象（表达式），可以放在赋值操作符两边的对象
	右值(readable 只读)：只能放在赋值操作符右边的值

进程表和进程数据结构
	进程表：
		内核在内核空间维护了一张表称为进程表，表中记录了所有进程的PID，以及指向这个进程的PCB的指针，PCB保存在每个进程的内核栈中
	进程上下文切换具体过程：
		进程A要切换到进程B时，首先要(陷入)进入内核，然后内核将CPU中关于进程A的进程信息（某些寄存器的值）保存在进程A内核栈的PCB结构中，
		然后从进程B内核栈的pcb结构中恢复进程B的信息到CPU的某些寄存器中，再退出内核回到进程B，这样cpu就开始执行进程B

进程状态及转化
	创建态：状态刚被创建出来的状态，很短暂立刻进入就绪态(就绪队列)
	就绪态：进程已经准备好可以运行了，存放在就绪队列中等待被调度，操作系统调度时就从就绪队列中选择下一个要运行的进程
	运行态：占用CPU资源执行的过程
	阻塞态(睡眠态)：进程因为某些原因停止了，让出cpu资源 
			可中断睡眠：允许接收外界信号和内核信号而被唤醒的睡眠
			不可中断睡眠：只能由内核发起信号唤醒，外界无法通过信号唤醒，只能在事件完成后由内核唤醒
	终止态

进程调度和调整优先级
	对于用户，进程的调度是随机的，但是，用户可以通过修改优先级间接影响linux的调度器，优先级越高，越有可能被先调度，在linux中，和window相反，为优先级高的任务分配更长的时间片，为优先级低的，分配更短的时间片
	linux系统中的调度器：
		完全公平调度算法（CFS）：默认的，
		实时调度算法：
	linux中通过命令nice或人renice手动修改进程的nice属性值，从而改变进程的优先级
		nice取值范围-20~19，默认0，值越小，优先级越高，-20最高，只有特权用户才能使用-20~0，普通用户只能使用正数优先级
	linux的实时调度类采用两个范围的nice值，将所有进程分为140个优先级队列，其中nice值在0~99范围内的是实时进程，nice值在100~139的进程是普通进程，这个范围映射到全局nice值，即-20~19，
		-20对应100，即能修改的范围只有100~139，0~99不能修改
	nice和renice区别：
		nice只能设置要运行的名义的优先级，renice可以改变已有进程的优先级，-n：指定优先级
			eg：nice -n 19 rm -rf /dir     删除目录时指定rm进程以低优先级运行
			        renice +10 64121（pid）

并行和并发
	并行：某一时刻能够同时处理多个进程，由于每个cpu核心在某一时刻只能执行一个程序，所有必须要使用多核才能达到真正的并行
	并发：站在操作系统宏观角度去看，同时有多个任务在执行，站在cpu的微观角度看，这些任务是一个一个处理的，某一时间点只有一个任务占用CPU

系统调用
	系统调用：就是操作系统提供给用户进程请求操作系统做一些特权操作的接口。
	发起系统调用的过程：
		发起系统调用，请求操作系统帮忙执行某些特权操作，这会产生软中断
		软中断操作系统导致陷入内核，CPU控制权交给操作系统，操作系统处理中断，即执行被请求的操作
		如果一切正常，操作系统在完成操作后会恢复到断点处继续向下执行，这会回到用户态
		用户进程取得操作系统操作的结果，继续向下执行

虚拟内存
	作用：实现进程的内存管理
	主要目标：
		1，对进程透明，进程不应该感知到内存被虚拟的事实
		2，保护进程，进程A不允许访问到进程B的虚拟内存，在进程A崩溃时也不应该让他影响到进程B，即每个进程都是完全隔离的

内核态和用户态
	进程分为两种：一是操作系统自身运行时的内核类进程，即操作系统进程，二是用户进程
		操作系统必须以一种最高权限的方式区运行，而其他用户进程不能有这个权限
		操作系统必须能够在任何有需要的时候暂停某个进程切换到操作系统内核，拿到cpu控制器
		为了限制用户进程的权限，cpu提供了两种运行模式：内核模式和用户模式，CPU中的一个从PSW程序状态字的寄存器的一个控制位保存了进程状态是那种模式

中断
	保证在任何时候可以将操作系统从用户态切换到内核态，将cpu的控制权交给操作系统

函数形参的入栈顺序为什么是从右往左
	1.这样的话，第一个参数的位置就在栈顶，我们很快就可以定位到第一个参数的位置,这样就可以定位后续的参数，	
	2.如果是从左往右压栈的话，最前面的参数就在栈底，除非知道参数个数，否则无法通过栈指针的相对位移求得最左边的参数，这样就变成了左边参数个数的不确定。

结构体为什么要对齐
	1.在32位或64位操作系统，数据总线是32位，地址总线也是32位，
	地址总线是32位，意味着寻址空间是按4递增的，数据总线时32位，意味着一次可以读4个字节，提高了cpu访问数据的效率，io操作很耗时;
	2.不完全按照4字节对齐，主要是从节省内存角度考虑。

头文件的作用
	.h头文件中一般存放同名.c文件中定义的变量、数组、函数的声明。
	作用：
		1.方便开发：比如一个函数在多个程序中使用，就需要在多个文件中写上声明，一旦这个函数原型发生变化，我们就需要更新所有用到它的文件中的声明，这是很麻烦也很容易出错的
			    把声明写在头文件中，用到这个函数的文件就不用一一写它的声明了，只要包含头文件即可，要修改也很方便
		2.头文件可以定义所用的函数列表，方便查看你可以调用的函数
		3.头文件只是声明，不占内存空间。

C语言编译流程
	C语言编译过程分成四个步骤： 
		①由.c文件到.i文件（-E），这个过程叫预处理 ，读取C语言源程序，对其中的伪指令
			1.删除所有#define，并且展开所有的宏定义
			2.处理所有的条件编译
			3.处理所有的#include预编译指定，将被包含的头文件插入到该编译指令的位置。
			4.删除所有的注释
			5.添加行号和文件名标识
		②由.i文件到.s文件(-S)，这个过程叫编译 ， 编译过程是整个程序构建的核心部分，编译成功，
			会将源代码由文本形式转换成汇编语言，编译过程就是把预处理完的文件进行一系列词法分析、
			语法分析、语义分析以及优化后生成相应的汇编代码文件。
		③由.s文件到.o文件(-c)，汇编过程调用汇编器as来完成，是用于将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。
		④由.o文件到可执行文件，这个过程叫链接，链接的主要内容就是将各个模块之间相互引用的部分正确的衔接起来。
			它的工作就是把一些指令对其他符号地址的引用加以修正。
		
		链接过程主要包括了符号解析和重定向
			1.符号解析
				符号可以是一个函数、全局变量或一个静态变量，其实就是指用符号来去标识一个地址。
				比如说 int a = 6;这样一句代码，用a来标识一个块4个字节大小的空间，空间里边存放的内容就是4.	
			2.重定位（地址回填）
				顾名思义，重新定位的意思。多个目标文件合并后相对于合并前的重新定位。文件a调用文件b中的函数或者变量时，需要知道其地址。但是未链接前，
				因为不在同一个文件，所以文件a不道其引用函数的地址，暂时用0x00000000或者其他临时假地址代替，真正的地址计算工作留给了链接器。链接器在完成地址
				和空间分配之后就已经可以确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正了。
		
				最基本的链接叫做静态链接，就是将每个模块的源代码文件编译成目标文件（Linux：.o  Windows：.obj），然后将目标文件和库一起链接形成最后的可执行文件。
				库其实就是一组目标文件的包，就是一些最常用的代码变异成目标文件后打包存放。最常见的库就是运行时库，它是支持程序运行的基本函数的集合。
				动态链接多调用的函数代码并没有被拷贝到应用程序的可执行文件当中，仅仅在其中加入了所调用函数的描述信息。只有应用程序被装入内存开始运行后，才会调用。

makefile如何编写
	makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至可以在makefile中执行shell脚本。
	makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率
	makefile是一个文件，make是一个工具，用来解释makefile中的指令。
	Makefile格式：
		1.一个规则
			目标：依赖条件
				命令
		note：①目标的时间必须晚于依赖条件的时间，否则更新目标
			  ②依赖条件如果不存在，找寻新的规则去产生依赖
			  ③Makefile文件中默认把第一组规则中的目标作为终极目标，用all：终极目标，可以指定终极目标
		2.函数：wildcard：可以进行文件匹配
		        patsubst：内容替换
		3.自动变量：$@：在规则的命令中，代表目标
		                    $^：在规则的命令中，代表全部依赖
		                    $<：在规则的命令中，代表第一个依赖，如果将$<应用在模式规则中，它可将依赖条件列表中的依赖条件依次取出，套用模式规则
		                    $?：在规则的命令中，所有比目标新的依赖的集合，以空格隔分
		4.伪目标：伪目标就是没有条件，只有目标和命令，然后再目标前面加了.PHONY关键字声明。它不代表一个真正的文件名，是一个“虚假”的目标。
			常见伪目标：all、clean、install（安装已经编译好的程序）、print（列出改变过的源文件）
		                .PHONY：clean all声明clean是伪目标

可执行程序分为哪几部分
	代码区：存放程序编译后的二进制代码
	常量区：存放字符串常量和只读变量
	全局（静态）存储区：存放全局变量和静态全局变量、静态局部变量。
			  初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。因此，又可以分为.data段和.bss段。
			  data段：存放已初始化的全局和静态变量。在编译器编译的时候，会给已初始化的数据分配内存空间，数据保存在目标文件中。
			  .bss段：存放未初始化或初始化为0的全局和静态变量。在编译器编译的时候，不会给该段的数据分配空间，只是记录数据所需的空间大小。
	堆区：由程序员手动申请/释放，若不手动释放，程序结束后由系统回收.【malloc申请的内存】
	栈区：由系统自动分配，存放函数参数、局部变量等
	
	从编译和执行的角度描述如下：可执行二进制程序 = 代码段(.text)＋初始化数据段(.data)+未初始化数据段(.bss)
		当程序被加载到内存单元时，则需要另外两个域：堆域和栈域，
		正在运行的C程序 = 代码段(.text)+初始化数据段(.data)+未初始化数据段(.bss)+堆(.heap)+栈（.stack）

进程和线程的区别
	进程：一个在内存中运行的应用程序，占用系统资源。
	线程：进程中的一个执行单元，负责当前进程中程序的执行。
	区别总结：
		 ①根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
		 ②资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；
					线程可以看做轻量级的进程，同一类线程共享代码和数据空间，
					每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。即线程有独立的PCB，但地址空间共享;
		 ③包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分
		 ④内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。
		 ⑤影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
		 ⑥执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

进程和线程的优缺点：
	多线程多进程
		多进程优点：
			1.编程容易，通常不需要考虑锁和同步资源的问题
			2.更强的容错性：一个进程崩溃，不会影响另一个进程
			3.每个进程间都有独立的地址空间和资源
		多进程缺点：
			1.逻辑控制复杂，需要和主程序交互
			2.开销大
		多线程优点：
			1.创建速度快，方便高效的数据共享
			2.线程间切换开销小
		缺点：
			1.线程之间同步与加锁控制比较麻烦
			2.一个线程的崩溃影响到整个程序的稳定
			3.到达一定的线程数后，即使再增加CPU也不能提高性能，
			4.每个线程与主程序公用地址，受限于0~4G的地址空间
				
进程和线程的使用场景：
	1.需要频繁创建销毁，优先考虑线程，比如web服务器
	2.需要进行大量计算（频繁切换cpu）的优先考虑线程
	3.强相关的处理用线程，弱相关用进程，比如消息收发和消息处理就是弱相关，消息处理中的消息解码和业务处理就是强相关
	在实际应用中，基本上都是“进程+线程”的结合方式	

进程间通信方式
	管道pipe：半双工的通信方式，数据只能单向流动，有血缘关系的进程使用
	命名管道fifo：半双工，任意进程使用；
	共享内存：直接分配一个共享空间，每个进程都可以访问，最快，当多个进程竞争共享资源时会造成数据的错乱
	信号：异步通信机制，但是不能携带数据
	套接字：可以跨网络与不同主机进程通信；
	mmap映射：

同步和异步的区别：
	同步：你给别人打电话，但对方占线，你就不停的打，知道打通为止，这样导致你其他的事情都干不了，而白白浪费了事件
	异步：当电话没打通的时候，你没有继续打，而是发了一条短信通知对方后去干别的事情了，当对方看见后，就回复你
	总之：同步就是我强依赖你，我必须等到答复，才能做出响应，如果没有收到恢复就一直处于等待状态，也就是阻塞状态，异步就是我并不强依赖你，我对你的响应时间不敏感，
	无论是否响应，我都可以继续执行，你响应了，我就做之前的事情，没响应就做其他事情，即我是非阻塞的。

	
	
	
什么是死锁；
	定义：两个或多个进程在执行过程中，由于竞争资源而造成的一种阻塞现象
	产生必要条件：
		互斥条件：一个资源每次只能被一个进程使用
		请求和保持条件：一个进程因请求资源而阻塞时，对已经获得的资源保持不放
		不抢占条件：进程已获得的资源，在未使用完之前，不能强行剥夺
		循环等待条件：若干进程之间形成一种头为相连的循环等待资源关系

	
gdb coredump 是什么
	当程序运行过程中检测到程序异常退出时（通过信号的方式通知目标进程响应的错误信息，常见信号有SIGBUS SIGSEGV），系统把程序当前内存状况存储在一个core文件中，叫做coredump，
	1.ulimit -a：查看core file 大小，若为0，则默认不使用coredump
	2.设置coredump文件大小：ulimit -c unlimited不限制大小
			          永久生效：修改配置文件/etc/profile  添加 ulimit -c 大小
	3.coredump文件存储位置：默认和可执行程序在同一目录
	4.gdb查看coredump文件
		定位出错误位置
		

回调函数怎么使用，回调函数意义
	使用：回调函数也是函数，它具有函数的所有特征，它可以有参数和返回值。单独给出一个函数是看不出来它是不是回调函数的。
	          回调函数区别于普通函数在于它的调用方式。只有当某个函数（更确切的说是函数的指针）被作为参数，被另一个函数调用时，它才是回调函数。
	意义：所谓回调函数就是把函数当作参数使用。目的是使程序更加普适。


宏定义跟const的区别
	const 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。
	define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。
	区别：①编译器处理方式不同：宏定义是在预处理阶段展开，const 变量是在编译运行阶段使用
	          ②类型和安全检查不同：#define 宏没有类型，不做任何类型检查，仅仅是展开。
				const 常量有具体的类型，在编译阶段会执行类型检查。
	          ③存储方式不同：define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
			     const常量会在内存中分配(可以是堆中也可以是栈中)。
	          ④const可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。

内核态和用户态	
	区别：在用户空间下执行，我们把此时运行的程序的这种状态称为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。
  	          当一个任务(进程)执行系统调用而陷入内核代码中执行时，我们就称进程处于内核状态。此时处理器处于特权级最高的(0级)内核代码。当进程处于内核态时，执行的内核代码会使用当前的内核栈。每个进程都有自己的内核栈。
	          当进程在执行用户自己的代码时，则称其处于用户态。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序而突然中断时，此时用户程序也可以象征性地处于进程的内核态。因为中断处理程序将使用当前进程的内核态。

什么是大小端及用程序验证



中断上下文、中断的上下部

new与malloc的区别
	new和delete是c++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持
	new和detele在对象创建的时候自动执行构造函数，在对象销毁的时候自动执行析构函数
	new返回指定类型的指针，并可以自动计算出所需空间大小，malloc必须用户指定大小，并且默认返回void *，必须强制转换为实际类型指针

memcyp与strcpy的区别
	参数不同
	执行效率不同
	结果不同
	
gdb调试，bt命令，如何处理段错误，怎么设置断点
	段错误：程序访问了一端不可访问的内存
	产生原因：解引用空指针、栈溢出、使用野指针、访问不可访问的内存空间、写一个只读区域等
	处理方法：gdb coredump

线程池
	定义：本质就是一个可以容纳多个线程的容器，其中线程可以反复使用，省去了频繁创建线程对象的操作
	优点：
		1.降低资源消耗：减少了创建和销毁线程的次数，每个线程都可重复使用，
		2.提高响应速度：当任务到达时，无需等到线程创建就能立即执行
		3.提高线程的可管理性，可以随时根据系统的承受能力，调整线程池中工作线程的数目，
	为什么使用线程池，而不是直接创建
		当频繁使用pthread_create创建多个线程，不仅消耗系统资源，还会降低系统稳定性
	核心参数：
		最大线程数
		核心线程数
		任务队列
	常见的线程池
		单线程化的线程池、
		定长线程池
		可缓存的线程池
	对线程池的操作
	        main:
		threadpool_create：创建线程池
		threadpool_add：在线程池中添加任务,默认添加一个任务，线程就借助回调函数执行一个任务
		销毁线程池
	

内存5大分区
	1、栈区(stack): —由编译器自动分配释放，存放函数的参数值，局部变量的值等。
	2、堆区(heap): 一般由程序员分配释放，若程序员不释放，程序结束时由系统释放。
	3、全局区(静态区,static): 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss。程序结束后由系统释放。
	                      在编译阶段(而非运行时)就分配空间,可读可写
	4、文字常量区: 常量字符串就是放在这里的。程序结束后由系统释放。
	5、程序代码区: 存放函数体的二进制代码。

阻塞和非阻塞？

编译时动态库和静态库
	动态库：库的代码不会编译进程序中，所以动态库编译的程序比较小
	             由动态库编译的程序依赖于系统的环境变量有没有这个库，没有则运行不了
	静态：库的整个代码编译进程序，程序比较大
	
gdb如何多线程调试，如何查看线程，如何跟踪线程
	跟踪线程attach  线程号    或者     gdb -p 线程号
	查看线程info thread显示进程当前所有线程   跟踪线程thread  num（info thread得到）
	查看线程执行到哪  bt
	
进程线程间通信：
	线程间通信：线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。
		①锁机制：包括互斥锁、条件变量、读写锁和自旋锁
		     互斥锁确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。
		     读写锁当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
		     条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
		      自旋锁上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况
		②信号量机制(Semaphore)
	进程间通信：
		①管道：可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制
		②信号：用于通知接收进程某个事件已经发生
		③共享内存：最快的进程间通讯的方式，共享内存直接在进程的虚拟地址空间进行操作，不再通过执行进入内核的系统调用来传递彼此的数据
		④套接字

内存溢出和内存泄漏
	内存溢出：指的是程序申请内存时，没有足够的内存供申请者使用。
	原因：
		1.以前申请的内存，用完之后没有及时清空，使得不能回收
		2.代码中循环或迭代次数过多
		3.内存中加载的数据量过于庞大，，比如一次从数据库中读取的数据太多
	
59.Gdb调试线程
      线程的查看：
	//查看当前运行的进程ps aux|grep a.out
	//查看当前运行的轻量级进程ps -aL|grep a.out
	//查看主线程和新线程的关系pstree -p 主线程id
      线程栈结构的查看：
	1. 获取线程ID
	2. 通过命令查看所有线程栈结构 pstack 主线程ID
       	3.查看单个线程的栈结构 pstack 线程id
       利用gdb查看线程信息
	①将运行的进程附加到gdb调试器当中，查看是否创建了新线程：gdb attach 主线程ID
	②查看线程的一些信息：
		//1.查看进程：info inferiors
		//2.查看线程：info threads   *代表当前线程
		//3.查看线程栈结构（默认是主线程）：bt   
			thread apply 1 2 bt：让编号为1,2的线程执行命令bt，显示栈帧信息
			thread apply 【编号 编号】【command命令】：让编号为多少的线程执行command命令
			thread apply all command：让所有线程执行命令command
		//4.切换线程：thread n（n代表第几个线程）
       利用gdb调试多线程
	1.设置断点在线程1：
		//1. 设置断点：break 行号/函数名
		//2. 查看断点：info b
	2.执行线程2的函数，指行完毕继续运行到断点处
		1. 继续使某一线程运行：thread apply 2（第几个线程） n（next）：让线程2执行自己的代码
		2. 重新启动程序运行到断点处：r
	3.只运行当前线程
		1. 设置：set scheduler-locking on
		2. 运行：n
	4.所有线程并发执行
		    1. 设置：set scheduler-locking off（默认状态 ）
    		    2. 运行：n


	补充：gdb调试多进程
	gdb调试的两种方式：
		1.直接调试法：gdb拉取新的进程，从头开始跑程序
			gdb a.out
		2.附着调试法：程序正在运行，gdb附着到已经存在的进程调试
			gdb attach pid
			步骤：1.运行程序test.c，gcc test.c -o test -g程序在getchar()卡住
			          2.ps aux | grep test 查看test的pid
		 	          3.gdb attach pid   是gdb附着在进程上
		

60.对Shell脚本的了解。
	什么是shell脚本？shell脚本是包含包含一个或多个命令的文本文件的命令。
	为什么要使用shell脚本？系统管理员使用它来发出许多命令来完成任务。 所有命令都在文本文件（shell脚本）中一起添加，以完成日常例行任务。

61.中断、异常、系统调用
	中断：硬件设备对操作系统提出的请求
	异常：非法指令或者其他原因导致当前的指令执行失败之后的处理请求，是cpu对于CPU内的事件的响应
	系统调用：应用程序主动向操作系统发出的服务请求
	区别：
		源头：
			1.中断：外设
			2.异常：程序意想不到的行为
			3.系统调用：应用程序请求操作系统提供服务
		响应方式：
			1.中断：异步
			2.异常：同步
			3.系统调用：同步或异步
		处理机制
			1.中断：持续，对用户应用程序透明
			2.异常：杀死或者重新执行意想不到的程序指令
			3.系统调用：等待或阻塞
				
62.内核地址是什么
	虚拟地址3G~4G空间：0xc0000000~0xffffffff
		普通区：
		直接映射区：内核将内核空间前896M和物理空间的前896M进行直接映射。虚拟地址=3G+物理地址，从该区域分配内存不会触发页表操作来建立映射关系，可以申请到物理内存上连续的内存区域。高端内存是指896M开始到1G的虚拟地址空间
			ZONE_DMA(16M) ZONE_NORMAL 16M~896M
		高端内存区：896M~结束
		动态映射区（120M）：该区域有vmalloc函数分配，特点：线性空间连续，但是对应物理空间不一定连续
		永久内存区映射区（4M）：用于映射高端内存
		固定内存映射区（4M）：
	
63.中断上下文和进程上下文
	进程上下文：
		进程的组成：
			内核区：
				内核栈、进程控制块：建立进程=>建立PCB=task_struct结构体，
					task_struct结构体成员：void *stack：指向进程内核栈（和成员thread_info在一起），
						     void* mm：指向0~3G的用户空间，
			用户区：
				代码、数据、堆和栈
			cpu的寄存器：进程的现场信息
			页表
		进程上下文概念：进程在执行时，CPU的寄存器值、进程的状态以及堆栈中的内容等信息，被称为进程上下文，即进程的物理实体（用户空间的代码和数据）和支持进程运行的环境（PCB、内核栈、寄存器）合成为进程上下文，
		用户及上下文：由进程的程序块、数据块、运行时的堆和用户栈等组成的用户空间信息被称为用户级上下文
		系统级上下文：由进程标识信息、进程现场信息、进程控制信息、和系统的内核栈组成的内核空间信息被称为系统级上下文
		寄存器上下文（硬件上下文、进程的现场信息）处理器各寄存器的内容。
		在进行进程上下文切换时，操作系统把下降进程的寄存器上下文保存在该进程自身的系统级上下文的现场进程信息（内核栈）中
		何时发送进程上下文切换：（进程状态的变化）
			1.进程自身产生一个异常（系统调用），进程有运行态进入阻塞态，   ---------主动
			2.或时间片原因，会由时钟中断迫使该进程进行上下文切换，进程有运行态进入就绪态  ---------被动
			note：用户进程的切换必须在操作系统的参与和帮助下完成，也就是说必须由操作系统（内核）接管cpu的控制权的基础上，才能完成进程上下文切换
			          异常和中断都可看做中断
			总结：要想进程进程上下文切换，操作系统必须首先得到cpu控制权
			          操作系统何时得到控制权
				1.Trap：进程执行了一个系统调用
				2.Exception：进程执行另一个意外的操作(异常)
				3.Interrupt：硬件设备产生中断，申请操作系统，比如时间中断、I/O中断
		下降进程的现场和断点保存在哪里
			保存在内核栈中，pcb中有一个指针指向内核栈，便于寻找
		下降进程保存现场的过程：
			1.当前栈指针sp指针指向用户栈栈顶---->切换--->sp指针的值被保存在内核栈，但是sp新的值指向内核栈栈顶
			2.程序状态（psw）---->切换--->内核栈
			3.断点（原来进程的pc寄存器值）---->切换--->pc的值保存在内核栈，但是pc新的值指向内核的中断处理程序
			4.通用寄存器---->切换--->内核栈中的中断处理程序中
		模式切换和进程切换：
			1，模式切换cpu还在同一个进程中或中断上下文，只是进程从用户态进入内核态，仅仅是保存了进入内核前的现场，不改变当前进程的空间等信息
			2，要发生进程切换，是指CPU转而去执行另一个进程，改变了当前进程的空间信息：
				a保存当期进程的硬件上下文
				b修改当前进程的pcb，比如进程状态的变化，并将该进程加入相关队列
				c调度另一个进程
				d修改被调度进程的pcb，改变其状态（系统级上下文）
				e⁮将‘当前进程’的存储管理数据改为被调度进程的存储管理数据信息（如页表）（切换用户级上下文）
				f恢复新进程的硬件上下文，让pc执行进程代码


	中断上文：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间，这个过程中，硬件的一些参数和变量要传给内核，内核通过这些参数进行中断处理。中断上文可以看做就是硬件传递过来的这些
		参数和内核需要保存的一些其他环境
	中断下文：执行在内核空间的中断服务程序。当工作在用户态的进程想访问某些内核才能访问的资源时，必须通过系统调用或中断才能进入内核态，有内核代替其执行。
	总结：中断上文对于实时性要求比较高的部分
	           中断下文做具体的，比较耗时的事情，属于中断的具体处理部分
		
68.Linux下的系统的调用，软件中断。
	系统调用的作用：
		1.允许向进程提供虚拟化的系统
		2.为用户空间提供硬件接口的一个抽象
		3.保证整个操作系统运行环境的安全性和稳定性
	系统调用处理函数：
		1.在linux中，系统调用时用户空间访问内核的唯一合法手段。用户进程在用户空间执行，系统调用时内核代码，不能直接调用
		2.操作系统是通过中断从用户态切换到内核态。中断就是一个软件或硬件请求。中断的两个属性：中断号和中断处理程序。操作系统维护了一张中断向量表，存储了所有中断的中断处理程序地址。
		3.系统调用都是通过软件中断实现的，x86系统上使用第128（$0x80）号中断（int 0x80指令），对应的系统调用处理函数为system_call( )
		4.新的x86处理器提供了专门的系统调用指令sysenter比int指令更高效
	操作系统有很多系统调用，对于同一个中断号如何处理有多个不同的系统调用？
		1.linux每个系统调用都有相应的系统调用号作为标识，系统调用号全局分配，不可改变。
		2.没有实现的系统调用依然占用相应的系统调用号，但是程序执行一个特殊的系统的系统调用函数sys_ni_syscall（），返回-ENOSYS
		3.内核维护一张系统调用表，sys_call_table，表中元素是系统调用函数的起始地址，系统调用号是表的偏移量，在x86上，系统调用号是通过eax寄存器传递给内核的。
		4.一旦将系统调用号放入寄存器，执行了int 0x80后，进入到内核空间，system_call()会检查系统调用号是否正确，若系统调用没有实现，则返回-ENOSYS，否则根据系统调用表调用相应的系统调用
	系统调用是需要提供参数的，并且具有返回值，这些参数是如何传递的
		1.一般参数传递（<=5）
			在linux中，按顺序使用ebx、ecx、edx、esi、edi寄存器，最多传递5个参数
		2.超过5个参数
			将其中一个寄存器作为地址指针，指向用户空间存储区中参数的起始地址，
		3.返回值放在eax寄存器中，0表示成功
		
69.管道的实现应该注意什么问题，怎么解决
	1.读管道的时候，如果管道中没有数据，当管道的写端都关闭的时候，read会返回0
				            当写端没有全部关闭的时候，read阻塞等待
	2.写管道的时候，当读端全部关闭时，进程异常终止（GIGPIPE）
		          当读端没有全部关闭，如果管道已满，则write阻塞
				                         未满，write成功
	3.原则上管道可以由一个读端多个写端，或一个写端多个读端，但这种情况应该尽量避免
	4管道是一种半双工的通信方式，要实现双向通信需要建立2个管道

71.怎么防止内存覆盖
	
76.长链接和短连接，有什么区别？
	短连接：在http1.0版本的时候，客户端与服务器完成一个请求和响应之后，会将之前的TCP连接断开，下次请求的时候又重新建立TCP连接
	长连接：在http1.1版本后带来一个新功能，在客户端与服务器完成一次请求和响应之后，允许不断开TCP连接，这意味着下次请求就直接使用这个TCP连接而不再重新建立TCP连接
	note：长连接指的是一次TCP连接允许多次HTTP会话，HTTP永远都是一次请求和响应，会话结束，HTTP本身不存在长连接之说
	           http请求的头部信息中：Connection：keep-alive表示服务器和客户端建立长连接
	长连接优缺点：
		优点：当网站中有大量资源就开启长连接
		缺点：当客户端请求一次之后不再请求，而服务器却开着长连接资源被占用，这样严重的浪费资源
77.中断函数与普通函数有啥区别
	中断服务函数应该注意的四大点：
		1.中断服务函数不能传参
		2.中断服务函数不能有返回值
			中断服务函数的调用是硬件级别的，当中断产生，pc指针强制跳转到对应的中断服务函数入口
		3.中断服务函数应做到短小精悍
		4.不要在中断函数中调用printf函数，会带来重入和性能问题
		
79.linux下查找文件的命令
	1.find ：按照文件格式查找
		按文件名查找：find 目录  -name "*.txt"
		按文件大小查找find /pathname  -size +1000k -
		按文件类型查找：find 目录  -type "f"
		按文件权限查找：
	2.grep按照文件内容查找：
	3.which、whereis命令：
		which：找到某一命令所在的位置，它是通过PATH路径进程查找的，找的是某一命令的可执行二进制文件
		which：找到某一命令所在的位置，它是通过PATH路径进程查找的，但他还会搜索其他的内容，加了-b就只查找二进制文件

82.文件系统
	1.低级格式化：划分磁道和扇区-----每个磁道的扇区是相等的
	2.高级格式化：构建一个文件系统（一组数据结构）
		分区表：划分磁盘-->partitions（分区）
		目录：
	命令fdisk -l查看当前系统磁盘数量
	Disklabel type：dos=>MBR分区
	Disk indentifier：disk id
	Device:
		/dev/sda:第a块硬盘设备
		/dev/sda1:第a块硬盘设备的第一个分区   （启动分区，里面有硬盘主引导记录（MBR，446字节）和分区表（64字节））
		boot：是不是启动分区（*）	
		start：起始扇区号
		end：最终的扇区号
		sectors：扇区数量
		size
		id：分区类型编号（83->liunx）
		type：分区类型编号对应的文字描述

83.进程间通信共享内存资源竞争问题
	1.临界资源：一次仅允许一个进程访问的共享资源
	   临界区：访问临界资源的那段代码
	2.临界资源访问方式
		1.硬件方式：
			关中断：每个进程进入临界区之后关闭所有中断，这样就不会把cpu切换到另一个进程了，离开前才重新打开中断------一个cpu的情况
			相关指令
		2.软件方式：
			1.锁机制
			2.信号量机制（P-、V+操作）
	3.信号量S
		semget：创建和访问一个信号量集
		semctl：信号量控制函数
		semop：改变信号量的值
		sem_p：
		sem_v：


86.临界区的底层实现


89.malloc分配内存失败的原因
	1.内存不足
	2.前面程序使用malloc函数时发生了内存访问越界，对未知的内存做了操作，致使maolloc不能继续分配内存
		解决方法：查找最近一次malloc的地方，查看这次malloc申请内存都做了什么，是否存在越界
90.malloc vmalloc kmalloc区别
	1.kmalloc、vmalloc是分配内核的内存，malloc是分配用户的内存
	2.kmalloc保证分配的内存在物理空间上是连续的，vmalloc和malloc保证虚拟内存上的连续
	3.kmalloc能分配的大小有限，vmalloc和malloc能分配的大小相对较大

91.互斥锁、读写锁
	互斥锁：用于保证任何时候，都只能有一个线程访问该对象。当获取锁失败的话，线程会进入睡眠，等待锁释放时被唤醒
	读写锁：分为读锁和写锁，处于读操作时，可以允许多个线程同时获得读操作。但同一时刻只能有一个线程可以获得写锁。写锁或阻塞其他读写锁，当一个线程获得写锁在写时，读锁也不能被其他线程获取，写锁优先级高
	区别：
		1.读写锁区分读和写，互斥锁不区分
		2.互斥锁同一时间只允许一个线程访问对象，无论读写；读写锁同一时间只允许一个写，但允许多个读
	自旋锁：在任何时刻都只有一个线程访问，党史当获取锁操作失败后，不会进入睡眠状态，而是会在原地自旋，知道锁释放。这样节省了线程从睡眠到被唤醒期间的消耗，在加锁事件短暂的环境下会极大的提高效率，但如果加锁时间长的话会非常浪费资源。

92.硬链接与软连接
	为了解决文件共享问题，引入软链接和硬链接
	若1个inode号对应多个文件名，则为硬链接，硬链接这块就是同一个文件使用了不同的别名，用ln创建
	若文件用户数据块存放的内容是另一个文件的路径名所指，则改文件为软链接，软链接是一个普通的文件，有自己独立的inode，但是其内部数据比较特殊

96.软中断和硬终端的区别
	1.硬件中断是由外设硬件发出的，具有随机性和突发性；软中断是执行中断指令产生的，无外部施加中断请求辛哈，因此中断的发生不是随机的，而是由程序安排好的
	2,硬中断的中断号是由中断控制器提供的，软中断的中断号是由指令直接给出，无需使用中断控制器
	3.硬中断是可以屏蔽的，软中断不可屏蔽
	4.硬件中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长事件，成为上半部
	5.软中断处理程序处理硬中断未完成的工作，是一种推后执行的机制，属于下半段。

		
		
		
		
		
	

		
	
		
	
		

		
	
	
		
	
		
	


