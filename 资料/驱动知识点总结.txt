0.1虚拟内存和物理内存
	1.虚拟内存
		进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，
		还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。
	2.进程开始要访问一个地址，它可能会经历下面的过程
		1.每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
		2.所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
		3.进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
		4.页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
		5.当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
		6.缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。
	MMU：
		内存管理单元，负责虚拟地址和物理地址的转换

22.内核态和用户态	
	区别：在用户空间下执行，我们把此时运行的程序的这种状态称为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。
  	          当一个任务(进程)执行系统调用而陷入内核代码中执行时，我们就称进程处于内核状态。此时处理器处于特权级最高的(0级)内核代码。当进程处于内核态时，执行的内核代码会使用当前的内核栈。每个进程都有自己的内核栈。
	          当进程在执行用户自己的代码时，则称其处于用户态。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序而突然中断时，此时用户程序也可以象征性地处于进程的内核态。因为中断处理程序将使用当前进程的内核态。

27.中断上下文、中断的上下部


31.内核移植和裁剪
	嵌入式系统包含硬件子系统和软件子系统
		软件子系统包含BootLoader、linux内核、文件系统、应用程序
	系统启动流程
		BootLoader->linux kernel(zImage)->rootfs(init)-->application
	系统移植的四部分：
		1.搭建交叉编译环境
		2.bootloader的选择和移植
		3.kernel的配置、编译移植和测试
		4.根文件系统的制作
	移植的基本步骤：
		1.确定目标机、主机的连接方式（串口、usb串行通信、TCP/IP、debug/jtag调试接口）
			【pc-开发板】环境搭建：主机程序开发，开发板执行显示结果
			 主句的数据传递如何到开发板：	包括uboot、kernel
				串口：普通文件，用来打印调试信息   
				网络接口：TFTP	
				调试：挂载（NFS）
			
		2.安装交叉编译环境（pc机的架构为x86,和ARM不兼容）
			为什么要交叉编译器？
				主机的架构是x86的cpu，单片机（目标机）是arm架构的cpu，主句和目标机不是一个平台，称为交叉。交叉编译器就是在一个平台上编译出能运行在另一个体系结构不同的平台上的程序。
				file命令：file 可执行程序，可以告诉我们可执行程序工作的平台的架构
			安装交叉编译器：直接安装
				解压缩：~/tiny210_porting/toolchain/arm-linux-gcc-4.5.1-v6-vfp-20120301.tar.gz
					sudo tar -zxvf arm-linux-gcc-4.5.1-v6-vfp-20120301.tar.gz -C /(这里解压到根文件，即/opt/FriendlyARM)
						/opt/FriendlyARM下有bin：交叉编译器的可执行命令
								    lib：arm-none-linux-gnueabi-gcc
								    arm-none-linux-gnueabi-：
								    share：
			使用方法：
				1. 简单方法：
					在/etc/environment下添加PATH环境变量
					arm-none-linux-gnueabi-gcc 1.c -o build
			  	2.使用绝对路径：
					/opt/FriendlyARM/bin/arm-none-linux-gnueabi-gcc 1.c -o build
								     
		3.搭建主句和目标机数据传输通道（TFTP、NFS）
		4.编译三大子系统
			uboot：.bin文件烧写到板子的flash或者sd卡中
				作用：初
			kernel：
				1.解压
				2.修改Makefile：进入解压后的linux-3.3.6后，打开Makefile，指定arm架构、交叉编译器位置修改为
						ARCH ? = arm
						CROSS_COMPLIE=/opt/FriendARM/toolchain/4.4.3/bin/arm-linux
				3.修改机器码：
					linux-3.3.4/arch/arm/tools目录下的mach-types 修改机器码，因为uboot和内核时候通过机器码以及名字匹配的
				4.cp linux-3.3.4/arch/arm/mach-smdkv210.c   linux-3.3.4/arch/arm/smdkv210.c 
					修改文件/smdkv210.c中的机器名字SMDK210为MINI210和uboot中的保持一致
				5.编译内核：cp linux-3.3.4/arch/arm/s5p210_defconfig .config 把开发板的配置文件拷贝到linux-3.3.4目录下的.config文件
					通过命令make menuconfig进入配置界面进行配置
						general setup->cross-conplier toolprefix输入编译器路径
						system types->
						boot option->
					编译内核：make uIamge
			让编译好的内核在开发板上运行：
				1.尽力tftp服务器
				2.启动编译好的内核：cp linux-3.3.5/arch/arm/boot/uImage tftpboot
					将编译好的内核拷贝到tftp服务器的根目录下
				3.将烧写好了uboot.bin的sd卡，插到开发板上
				4.将开发板可主句连接，ping  192.168.186.30(主机ip) 
				5.在开饭输入 tftp uImage，把tftp服务器的uImage文件拷贝到开发板
				6.bootm启动内核 
			根文件系统：
				1.制作根文件系统
				2.挂载根文件系统：NFS挂载根文件系统，有利于开发过程中的同步
					a.make menuconfig :file system->network file system->root file system on NFS,保存退出，重新编译make uImage，并拷贝到tftp服务器目录下
					b.设置nfs环境变量
			
		5.烧写测试
	
33.字符设备驱动框架
	1.实现模块加载和卸载入口函数
	2.在模块加载入口函数中	
		a.为设备对象申请空间
		b.申请设备号，用于区分不同的字符设备
		c.创建设备节点文件，为用户提供一个可操作的文件接口
		d.硬件的初始化
			1.地址的映射ioremap			
			2.中断的申请
			3.实现硬件寄存器的初始化
		e.实现file_operation结构体


45.字符设备和块设备区别
	字符设备：按照字节流的方式被有序访问的设备，比如串口、键盘、鼠标
	块设备：系统中能够随机访问（不需要按顺序）访问固定大小数据片的设备，比如，硬盘、闪存
	区别：是否可以被随机访问，即能否在访问设备的时候随意地从一个位置跳到另一个位置

46.交叉开发的目的，流程；内核的启动流程
	内核启动流程：系统刚上电时，处理器会执行bootloader，初始化处理器和外设，然后调用linux内核，linux内核在完成系统的初始化后需要挂载某个文件系统作为根文件系统，
		       然后加载必要的内核模块，启动应用程序
	bootloder：初始化ram，因为内核一般在ram中运行、
		    初始化串口，串口用于在启动过程打印调试信息，便于了解linux的启动过程
		    初始化硬件：网卡、时钟、
		    设置linux内核启动参数
		
54.IIc UART SPI的时序图描述
	两种通信方式：
		并行通信：数据各个位同时发送，传输速度快，占用引脚资源多
		串行通信：数据各按位顺序传输，传输速度相对较慢，占用引脚资源少
		             按照数据传输方向分为：
			单工：数据传输只支持数据在一个方向上传输
			半双工：允许数据在两个方向上传输，但，某一时刻，只允许数据在一个方向上传输
			全双工：允许数据同时在两个方向上传输
		             串行通信的通信方式：
			同步通信：带时钟同步信号传输
	 		异步通信：不带时钟同步信号    UART，事先约定好比特率
	UART（通用异步接收发器）：串口 异步通信 全双工     USART（通用同步异步接收发器）
	        主机和从机至少要接三根线，RX，TX和GND.TX用于发送数据，RX用于接受数据（收发不是一根线，所以是全双工方式）。
	        两个设备通过UART通信，那么A设备的RX应该与B设备的TX连接、A设备的TX与B设备的RX连接，
	        如果一方为PC机，一方为单片机。需要将TTL/CMOS（单片机电平）转换为RS232（PC机电平）。因为TTL/CMOS电平范围为0-1.8/2.5/3.3/5V，逻辑上1表示高电平，0表示低电平。RS232的电平范围为-12-12V，-5~ -12V表示高电平，5-12V表示低电平
	        数据协议：串口通信重要参数：起始位、数据位、奇偶校验位、停止位、波特率设置
		数据协议：以PC机一给单片机乙发数据为例（1为高电平，0为低电平）：A.TX to B.RX.刚开始B.RX的端口保持1，当A.TX发来 个0作为起始位告诉乙我要发数据了！然后就开始发数据，发多少呢？通常一次是8位，这个双方事先要用软件设置好.
		第9位可以为奇偶校验位。PC机一般会用串口助手设置，单片机会在UART的驱动中设置。一小帧数据发送完了以后，A.TX给个高电平告诉B.RX我发完了一帧。如果还有数据，就再给个0然后重复上一步。如果双方约定由校验位，还要在发停止位1之前发送个校验位。
	SPI：全双工同步串行总线，
	       SPI工作原理总结：
		①硬件上为4根线：MISO 主设备数据输入，从设备数据输出。MOSI 主设备数据输出，从设备数据输入。SCLK 时钟信号，由主设备产生。CS 从设备片选信号，由主设备控制。
		②主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行移位寄存器写入一个字节来引起一次传输
		③串行移位寄存器通过MOSI信号线将字节传送给从机，从机同时也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机。这样，两个寄存器中的内容就被交换。
		④外设的写操作和读操作是同步完成的。如果只进行写操作，主句只需要忽略收到的字节即可；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引起从机的传输。

	IIC：两线式的半双工串行通信：一个时钟线SCL和一个数据线SDA。只有一根数据线，可发送和接收数据，在cpu和被控IIC设备，IIC设备与IIC设备直接进行双向传输
	        空闲状态：SCL 和 SDA空闲状态默认都为高电平
	        开始信号：当SCL为高电平期间，SDA由高到低的跳变，启动信号是一种电平跳变时序信号，而不是一个电平信号
	        停止信号：当SCL为高电平期间，SDA由低到高的跳变，启动信号是一种电平跳变时序信号，而不是一个电平信号
	        应答信号：发送器每发送一个字节（8位），就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位，表示接收器以及成功接收了该字节；
		        应答信号为高电平时，规定为非应答位，表示接收器接收该字节没有成功。对于反馈有效应答ACK的要求是，接收器在第9个时钟脉冲之前的低电平期间将sda拉低，并且确保在改时钟的高电平期间为稳定的低电平。
	        数据的有效性：数据传输时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟信号为低电平时，数据线上的电平状态才允许变化。
		  	即数据在SCL的上升沿到来前必须就准备好，并在下降沿到来之前必须保持稳定
	        数据传输：在iic总线上每一个数据都有一个时钟脉冲相对应，数据位的传输是边沿触发

59.Gdb调试线程
      线程的查看：
	//查看当前运行的进程ps aux|grep a.out
	//查看当前运行的轻量级进程ps -aL|grep a.out
	//查看主线程和新线程的关系pstree -p 主线程id
      线程栈结构的查看：
	1. 获取线程ID
	2. 通过命令查看所有线程栈结构 pstack 主线程ID
       	3.查看单个线程的栈结构 pstack 线程id
       利用gdb查看线程信息
	①将运行的进程附加到gdb调试器当中，查看是否创建了新线程：gdb attach 主线程ID
	②查看线程的一些信息：
		//1.查看进程：info inferiors
		//2.查看线程：info threads   *代表当前线程
		//3.查看线程栈结构（默认是主线程）：bt   
			thread apply 1 2 bt：让编号为1,2的线程执行命令bt，显示栈帧信息
			thread apply 【编号 编号】【command命令】：让编号为多少的线程执行command命令
			thread apply all command：让所有线程执行命令command
		//4.切换线程：thread n（n代表第几个线程）
       利用gdb调试多线程
	1.设置断点在线程1：
		//1. 设置断点：break 行号/函数名
		//2. 查看断点：info b
	2.执行线程2的函数，指行完毕继续运行到断点处
		1. 继续使某一线程运行：thread apply 2（第几个线程） n（next）：让线程2执行自己的代码
		2. 重新启动程序运行到断点处：r
	3.只运行当前线程
		1. 设置：set scheduler-locking on
		2. 运行：n
	4.所有线程并发执行
		    1. 设置：set scheduler-locking off（默认状态 ）
    		    2. 运行：n


	补充：gdb调试多进程
	gdb调试的两种方式：
		1.直接调试法：gdb拉取新的进程，从头开始跑程序
			gdb a.out
		2.附着调试法：程序正在运行，gdb附着到已经存在的进程调试
			gdb attach pid
			步骤：1.运行程序test.c，gcc test.c -o test -g程序在getchar()卡住
			          2.ps aux | grep test 查看test的pid
		 	          3.gdb attach pid   是gdb附着在进程上
		

61.中断、异常、系统调用
	中断：硬件设备对操作系统提出的请求
	异常：非法指令或者其他原因导致当前的指令执行失败之后的处理请求，是cpu对于CPU内的事件的响应
	系统调用：应用程序主动向操作系统发出的服务请求
	区别：
		源头：
			1.中断：外设
			2.异常：程序意想不到的行为
			3.系统调用：应用程序请求操作系统提供服务
		响应方式：
			1.中断：异步
			2.异常：同步
			3.系统调用：同步或异步
		处理机制
			1.中断：持续，对用户应用程序透明
			2.异常：杀死或者重新执行意想不到的程序指令
			3.系统调用：等待或阻塞
				
62.内核地址是什么
	虚拟地址3G~4G空间：0xc0000000~0xffffffff
		普通区：
		直接映射区：内核将内核空间前896M和物理空间的前896M进行直接映射。虚拟地址=3G+物理地址，从该区域分配内存不会触发页表操作来建立映射关系，可以申请到物理内存上连续的内存区域。高端内存是指896M开始到1G的虚拟地址空间
			ZONE_DMA(16M) ZONE_NORMAL 16M~896M
		高端内存区：896M~结束
		动态映射区（120M）：该区域有vmalloc函数分配，特点：线性空间连续，但是对应物理空间不一定连续
		永久内存区映射区（4M）：用于映射高端内存
		固定内存映射区（4M）：
	
63.中断上下文和进程上下文
	进程上下文：
		进程的组成：
			内核区：
				内核栈、进程控制块：建立进程=>建立PCB=task_struct结构体，
					task_struct结构体成员：void *stack：指向进程内核栈（和成员thread_info在一起），
						     void* mm：指向0~3G的用户空间，
			用户区：
				代码、数据、堆和栈
			cpu的寄存器：进程的现场信息
			页表
		进程上下文概念：进程在执行时，CPU的寄存器值、进程的状态以及堆栈中的内容等信息，被称为进程上下文，即进程的物理实体（用户空间的代码和数据）和支持进程运行的环境（PCB、内核栈、寄存器）合成为进程上下文，
		用户及上下文：由进程的程序块、数据块、运行时的堆和用户栈等组成的用户空间信息被称为用户级上下文
		系统级上下文：由进程标识信息、进程现场信息、进程控制信息、和系统的内核栈组成的内核空间信息被称为系统级上下文
		寄存器上下文（硬件上下文、进程的现场信息）处理器各寄存器的内容。
		在进行进程上下文切换时，操作系统把下降进程的寄存器上下文保存在该进程自身的系统级上下文的现场进程信息（内核栈）中
		何时发送进程上下文切换：（进程状态的变化）
			1.进程自身产生一个异常（系统调用），进程有运行态进入阻塞态，   ---------主动
			2.或时间片原因，会由时钟中断迫使该进程进行上下文切换，进程有运行态进入就绪态  ---------被动
			note：用户进程的切换必须在操作系统的参与和帮助下完成，也就是说必须由操作系统（内核）接管cpu的控制权的基础上，才能完成进程上下文切换
			          异常和中断都可看做中断
			总结：要想进程进程上下文切换，操作系统必须首先得到cpu控制权
			          操作系统何时得到控制权
				1.Trap：进程执行了一个系统调用
				2.Exception：进程执行另一个意外的操作(异常)
				3.Interrupt：硬件设备产生中断，申请操作系统，比如时间中断、I/O中断
		下降进程的现场和断点保存在哪里
			保存在内核栈中，pcb中有一个指针指向内核栈，便于寻找
		下降进程保存现场的过程：
			1.当前栈指针sp指针指向用户栈栈顶---->切换--->sp指针的值被保存在内核栈，但是sp新的值指向内核栈栈顶
			2.程序状态（psw）---->切换--->内核栈
			3.断点（原来进程的pc寄存器值）---->切换--->pc的值保存在内核栈，但是pc新的值指向内核的中断处理程序
			4.通用寄存器---->切换--->内核栈中的中断处理程序中
		模式切换和进程切换：
			1，模式切换cpu还在同一个进程中或中断上下文，只是进程从用户态进入内核态，仅仅是保存了进入内核前的现场，不改变当前进程的空间等信息
			2，要发生进程切换，是指CPU转而去执行另一个进程，改变了当前进程的空间信息：
				a保存当期进程的硬件上下文
				b修改当前进程的pcb，比如进程状态的变化，并将该进程加入相关队列
				c调度另一个进程
				d修改被调度进程的pcb，改变其状态（系统级上下文）
				e⁮将‘当前进程’的存储管理数据改为被调度进程的存储管理数据信息（如页表）（切换用户级上下文）
				f恢复新进程的硬件上下文，让pc执行进程代码


	中断上文：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间，这个过程中，硬件的一些参数和变量要传给内核，内核通过这些参数进行中断处理。中断上文可以看做就是硬件传递过来的这些
		参数和内核需要保存的一些其他环境
	中断下文：执行在内核空间的中断服务程序。当工作在用户态的进程想访问某些内核才能访问的资源时，必须通过系统调用或中断才能进入内核态，有内核代替其执行。
	总结：中断上文对于实时性要求比较高的部分
	           中断下文做具体的，比较耗时的事情，属于中断的具体处理部分
		
68.Linux下的系统的调用，软件中断。
	系统调用的作用：
		1.允许向进程提供虚拟化的系统
		2.为用户空间提供硬件接口的一个抽象
		3.保证整个操作系统运行环境的安全性和稳定性
	系统调用处理函数：
		1.在linux中，系统调用时用户空间访问内核的唯一合法手段。用户进程在用户空间执行，系统调用时内核代码，不能直接调用
		2.操作系统是通过中断从用户态切换到内核态。中断就是一个软件或硬件请求。中断的两个属性：中断号和中断处理程序。操作系统维护了一张中断向量表，存储了所有中断的中断处理程序地址。
		3.系统调用都是通过软件中断实现的，x86系统上使用第128（$0x80）号中断（int 0x80指令），对应的系统调用处理函数为system_call( )
		4.新的x86处理器提供了专门的系统调用指令sysenter比int指令更高效
	操作系统有很多系统调用，对于同一个中断号如何处理有多个不同的系统调用？
		1.linux每个系统调用都有相应的系统调用号作为标识，系统调用号全局分配，不可改变。
		2.没有实现的系统调用依然占用相应的系统调用号，但是程序执行一个特殊的系统的系统调用函数sys_ni_syscall（），返回-ENOSYS
		3.内核维护一张系统调用表，sys_call_table，表中元素是系统调用函数的起始地址，系统调用号是表的偏移量，在x86上，系统调用号是通过eax寄存器传递给内核的。
		4.一旦将系统调用号放入寄存器，执行了int 0x80后，进入到内核空间，system_call()会检查系统调用号是否正确，若系统调用没有实现，则返回-ENOSYS，否则根据系统调用表调用相应的系统调用
	系统调用是需要提供参数的，并且具有返回值，这些参数是如何传递的
		1.一般参数传递（<=5）
			在linux中，按顺序使用ebx、ecx、edx、esi、edi寄存器，最多传递5个参数
		2.超过5个参数
			将其中一个寄存器作为地址指针，指向用户空间存储区中参数的起始地址，
		3.返回值放在eax寄存器中，0表示成功
	

72.IIc详解
	1.IIC总线是一种多主机总线，IIC总线上可以挂载多个设备：多个主机（单片机），多个从机（外设），主机有权发起和结束一次通信，而从机只能
	   被主机呼叫，当总线上有多个主机同时启用总线时，IIC也具备冲突检测和仲裁功能来防止错误产生。
	2.每个连接到iic总线上的器件都有一个唯一的地址（7bit），且每个器件都可以做为主机和从机（同一时刻只能有一个主机），主机和其他器件之间的数据传输可以由主机发送到其他器件，
	这是主机为发送器，总线上接收数据的器件为接收器
	3iic通信过程：
		1.主机发送起始信号启用总线（其他主机就不会启用总线了，其他从机就知道有主机要通信了）
		2.主机发送一个字节数据指明从机地址和后续字节的传送方向（最低位为0表示主机给从机发，1表示从机给主机发，高7位为从机地址）
		3.被寻址的从机发送应答信号回应主机（）
		4.发送器发送一个字节
		5.接收器发送应答信号回应发送器
		循环步骤4.5（通信顺序不能变）
		n.通信完成后主机发送停止信号释放总线（其他主机也能接收到，其他主机就可以启用总线了，从机也接收到了）
	4.iic总线寻址方式
		iic总线发送的数据是广义的，既包含地址，又包含真正的数据
		主机在发送起始信号后必须先发送一个字节的数据，高7位表示从机地址，最低位表示后续字节的传递方向，0表示主机发送数据，
		1表示主机接收数据；总线上所有的从机接收到该字节数据后都将这7位地址与自己的地址进行比较，如果相同，则认为自己被主机寻址，
		然后根据最低位将自己定义为发送器或接收器
	5.起始信号：scl为高电平时，sda由高到低
	   停止信号：scl为高电平时，sda由低到高
	   字节传送和应答：iic总线通信时每个字节为8位，数据传送时，先传送最高位，后发地位，发送器发送完一个字节后，接收器必须发送以为应答位来回应发送器，即一帧数据共9位
	   	当一个字节发送完了后，应答信号是在第九个时钟SCL为低电平期间，接收器发送低电平到数据线，在SCL为高电平时，发送器从SDA上读取应答信号
	   同步信号：iic总线在进行数据传送时，时钟线SCL为低电平期间发送器向数据线上发送一位数据，在此期间数据线上的信号允许变化，时钟线SCL为高电平期间接收器从数据线上读取
		一位数据，在此期间数据线上的信号不允许发送变化，必须保持稳定。
	6.典型iic时序
		主机向从机发送数据：
			S->从机地址+0->从机A->主机数据->从机A->主机数据->从机A/~A->P
		从机向主机发送数据：
			S->从机地址+1->A->从机数据->主机A->从机数据->主机不应答~A->P
		主机先给从机发，然后从机给主机发数据
	7.iic仲裁
		iic仲裁分为两部分：SCL同步和SDA的仲裁
		SCL同步：由于总线具有线与的逻辑功能，只要有一个期间发送低电平，总线就位低电平，所有期间发送高电平，总线才会高电平
		SDA仲裁：SDA仲裁也是建立在总线具有线与的逻辑功能原理上的，主机在发送1位数据后，比较总线上的数据和自己发送的额数据是否一致，一致就继续发送，不一致退出竞争

73.uart总线详解
	1.是一种串行异步通信协议，有两根数据线，  
	2.波特率：串口通信速度单位，单位为bps（每秒传送的二进制位）
	3.UART帧格式：
		空闲位（高电平）->起始位（1位，低电平）->数据位（先发低位，再发高位，一般习惯发8位，可以发5、6、7、8位）->校验位（可有可无）->停止位（1位或1.5位或2位，高电平）->空闲位
		note：串口协议规定：数据线在空闲的时候为高电平；串口一次最多发一个字节，要发多个字节，就发送多次，这是因为串口通信的双方没有一个同一的时间基准，时间长的话就有一个累计误差。

74.SPI详解
	1.概念：是一种高速、全双工、同步的通信总线；采用主从方式工作，一般有一个主设备（管理总线）和一个或多个从设备，SPI需要至少四根线，分别是MISO（主设备输入，从设备输出）、MOSI（主设备输出，
		从设备输入）、cs（片选信号，每个从机需要一个片选信号，对于主机而言，有多个从设备就有多个cs）、SCLK（时钟）。
	2.寻址方式：当主设备要和某个从设备进行通信时，主设备需要先向对应从设备的片选线上发送使能信号，表示选中该从设备
		note：怎么判断cs是高电平使能和低电平使能？   cs：高电平，~cs：低电平使能
	3.通信过程：SPI总线在进行数据传输的时候，先传输高位，后传送地位，一个字节传送完成后无需应答位即可开始下一个字节的传送；SPI总线采用同步方式工作，时钟线在上升沿或下降沿的时候发送器向数据线上发送
		数据，在紧接着的下降沿或上升沿接收器从数据线上读取数据，完成一位数据传送，八个时钟周期即可完成一个字节数据的传送。
	4.极性和相位：
		SPI总线有四种不同的工作模式，取决于极性（CPOL）和相位（CPHL）这两个因素，即SPI有四种工作模式
		CPOL表示SCLK空闲时的状态	
			CPOL=0：空闲时SCLK为低电平
			CPOL=1：空闲时SCLK为高电平	
		CPHL表示采样时刻
			CPHL=0：每个时钟周期的第一个时钟沿采样，即上升沿
			CPHA=1：每个时钟周期的第二个时钟沿采样
		总结 ：
			1.CPOL=0、CPHL=0：表示下降沿发送方发数据，上升沿接收方读数据
			2.CPOL=0、CPHA=1：表示上升沿发送方发数据，下降沿接收方读数据
			3.CPOL=1、CPHL=0：表示上升沿发送方发数据，下降沿接收方读数据
			4.CPOL=1、CPHA=1：表示下降沿发送方发数据，上升沿接收方读数据
		对于从机，出厂时工作模式固定，所以我们需要对主设备的极性和相位进行配置，和从设备保持一致
	5.IIC和SPI比较
		相同点：
			1.均采用串行、同步方式
			2.均采用TTL电平，传输距离和应用场景类似
			3.均采用主从工作方式
		不同:
			1.iic是半双工，spi是全双工
			2.iic有应答机制，SPI没有应答		
			3.寻址方式不同，iic通过向总线广播从机地址进行寻址（节省硬件资源），spi通过向从机发送使能信号来寻址（节省时间）
			4.iic的时钟极性和时钟相位固定，spi的时钟极性和时钟相位可调

77.中断函数与普通函数有啥区别
	中断服务函数应该注意的四大点：
		1.中断服务函数不能传参
		2.中断服务函数不能有返回值
			中断服务函数的调用是硬件级别的，当中断产生，pc指针强制跳转到对应的中断服务函数入口
		3.中断服务函数应做到短小精悍
		4.不要在中断函数中调用printf函数，会带来重入和性能问题

82.文件系统
	1.低级格式化：划分磁道和扇区-----每个磁道的扇区是相等的
	2.高级格式化：构建一个文件系统（一组数据结构）
		分区表：划分磁盘-->partitions（分区）
		目录：
	命令fdisk -l查看当前系统磁盘数量
	Disklabel type：dos=>MBR分区
	Disk indentifier：disk id
	Device:
		/dev/sda:第a块硬盘设备
		/dev/sda1:第a块硬盘设备的第一个分区   （启动分区，里面有硬盘主引导记录（MBR，446字节）和分区表（64字节））
		boot：是不是启动分区（*）	
		start：起始扇区号
		end：最终的扇区号
		sectors：扇区数量
		size
		id：分区类型编号（83->liunx）
		type：分区类型编号对应的文字描述

90.malloc vmalloc kmalloc区别
	1.kmalloc、vmalloc是分配内核的内存，malloc是分配用户的内存
	2.kmalloc保证分配的内存在物理空间上是连续的，vmalloc和malloc保证虚拟内存上的连续
	3.kmalloc能分配的大小有限，vmalloc和malloc能分配的大小相对较大

91.互斥锁、读写锁
	互斥锁：用于保证任何时候，都只能有一个线程访问该对象。当获取锁失败的话，线程会进入睡眠，等待锁释放时被唤醒
	读写锁：分为读锁和写锁，处于读操作时，可以允许多个线程同时获得读操作。但同一时刻只能有一个线程可以获得写锁。写锁或阻塞其他读写锁，当一个线程获得写锁在写时，读锁也不能被其他线程获取，写锁优先级高
	区别：
		1.读写锁区分读和写，互斥锁不区分
		2.互斥锁同一时间只允许一个线程访问对象，无论读写；读写锁同一时间只允许一个写，但允许多个读
	自旋锁：在任何时刻都只有一个线程访问，党史当获取锁操作失败后，不会进入睡眠状态，而是会在原地自旋，知道锁释放。这样节省了线程从睡眠到被唤醒期间的消耗，在加锁事件短暂的环境下会极大的提高效率，但如果加锁时间长的话会非常浪费资源。

92.硬链接与软连接
	为了解决文件共享问题，引入软链接和硬链接
	若1个inode号对应多个文件名，则为硬链接，硬链接这块就是同一个文件使用了不同的别名，用ln创建
	若文件用户数据块存放的内容是另一个文件的路径名所指，则改文件为软链接，软链接是一个普通的文件，有自己独立的inode，但是其内部数据比较特殊

96.软中断和硬终端的区别
	1.硬件中断是由外设硬件发出的，具有随机性和突发性；软中断是执行中断指令产生的，无外部施加中断请求辛哈，因此中断的发生不是随机的，而是由程序安排好的
	2,硬中断的中断号是由中断控制器提供的，软中断的中断号是由指令直接给出，无需使用中断控制器
	3.硬中断是可以屏蔽的，软中断不可屏蔽
	4.硬件中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长事件，成为上半部
	5.软中断处理程序处理硬中断未完成的工作，是一种推后执行的机制，属于下半段。
	
37.arm有多少寄存器，CPSR和SPSR作用
	arm有两个级别：特权级别、非特权级别（用户模式）
	arm有7工作模式：同一时刻只能工作在一种模式，占用一组寄存器
		用户模式：
		系统模式：
		快速中断模式：
		未定义命令模式：
		管理模式：内核一般工作在管理模式
		普通中断模式：
		中止模式：
	37个，31个通用寄存器，6个状态寄存器
	通用寄存器包括r0~r15，可以分为3类：
		未分组的r0~r7：通用寄存器，存放数据临时变量
		分组寄存器r8~r14：r8~r12：通用寄存机，存放数据临时变量，r13（sp）：栈指针寄存器，记录栈顶指针；r14（LR）：连接返回寄存器，保存程序的返回地址，如函数调用返回
		程序计数器（r15，pc寄存器）：pc指向那个地址，cpu就到那个地址去取指令执行
	状态寄存器：
		CPSR：当前程序状态寄存器：保存了程序的运行状态，比如进程上下文切换时，保存进程状态
			低5位：CPU的工作模式
			T标志位：切换CPU的工作状态：arm状态（32位）、thumb状态（CPU指令16位）
			F标志位：快速中断开关
			I标志位：普通中断开关
			8~27位：保留
			V标志位：
			C标志位：进位标志位
			Z标志位：溢出位
			N标志位：
		SPSR：备份程序状态寄存器，每种异常模式都对应一个spsr寄存器，当中断或异常出现时候，spsr用来存储cpsr寄存器的状态，以便异常或中断返回后恢复之前的工作状态。
	存储设备：
		非易失性存储介质：断电保存，bootloader存储
		易失性存储介质：断电则数据丢失，比如内存、flash
	bootloader存储位置：
		1.nor flash最低地址上启动：容量非常小，价格高，是总线设备，当cpu加电后，不需要任何驱动，CPU可以访问总线设备
			1.cpu刚一加电，从0地址开始执行，nor flash一般会通过地址总线接到CPU的0地址，这样可以保证cpu加电后，去0地址执行bootloader代码。boot去初始化内存控制器，nand flash控制器等硬件。
				bootloader：分为代码段和数据段，nor flash可读不可写
					数据段：在初始化内存之前，优先将数据段内容拷贝到开发板内部的iram（4k，随机静态存储器中），这样如果需要对bootloader的局部变量段进行读和写的时候，直接在iram当中读取即可，这是通过让r13栈指针寄存器指向iram实现的
			2.kernerl放在nand flash上，boot初始化好硬件设备后，bootloader先把kernel拷贝到内存当中，然后把kernel的启动参数拷贝到内存中，最后bootloader把寄存器r0（板子的编号）,r1（kernel启动参数（比如开发板串口波特率等））,r2（0）进行赋值，最后让cpu跳到kernel的所在内存去执行，
				实际上cpu先执行的是kernel前面自带的解压缩代码，解压出kernel，然后CPU去执行真正的kernel的时候获取到3个寄存器的参数，
			3.根文件系统也放在nand flash上
			总结：arm9系列：把bootlader烧写到nor flash上，把kernel烧写到nand flash上，然后cpu加电后，先去nor flash上执行bootloader，bootloader初始化硬件，再去nand flash上把kernel加载出来，拷贝到内存当中区，然后给kernel传递适当的参数，
					最后cpu跳转到 内存执行kernel，最终kernel会把硬件再初始化一遍。
		2.nand flash上启动：容量大、价格低、非总线设备
			比如s5pv210芯片：内部有96KiRAM（易失性存储介质），64KiROM（非易失性存储介质） 512MDDRAM（内存）、245M nand flash、sd卡
			iROM：存放三星的固化代码
			 nand flash分为3个部分：
				存放bootloader、存放kernel、存放根文件系统
			启动流程：
				1.cpu加电后，先执行iROM中的固化代码，在这段代码中，会初始化时钟，判断启动方式（SD卡、nand、串口、网卡等），若判断从nand中启动，三星会拷贝nand中的前8K的bootloader到iRAM中，
				2.cpu到iRAM中执行前8K的bootloader，这段代码完成了基本的硬件初始化，比如驱动nand flash，配置时钟、驱动ddram，以及把完整的bootloader自加载到内存，然后cpu在跳转到内存中继续执行，驱动一些非重要的驱动等，再去执行loder功能。
				3.loder阶段，把kernel拷贝到内存，以及传递kernel的启动参数，设置号r0，r1，r2寄存器的值，最后，CPU跳转到kernel所在内存，先解压缩kernel到内存，再去执行真正的kernel
				4.kernel启动起来后，kernel去挂载（mount）根文件系统
		3,sd卡启动（非总线设备）
			1.同理，开机后，如果判断时sd卡启动，则先拷贝sd卡的前8k到开发板的iRam中，然后cpu执行iRAM中的前8k，初始化好基础的硬件设备，再进行bootloader自拷贝到内存，接着cpu到内存当中执行继续bootloader，
			2.在loader阶段，有两个选择，加载kernel
					              进入命令界面



		遇到的问题：
			1.make的时候不能找到编译器，修改Makefile中的cross_compile
			2.machine ID内核无法启动，更改uboot编号使其与内核编号保持一致。内核编号由arch/arm/mach-s3c2440/mach-mini2440.c的MACHINE_START(MINI2440,"FRIENDLYARM MINI2440 development board")的mini2440决定
				打开/include/asm-arm/mach-type.h搜索mini2440可以看到#define MACH_TYPE_MINI2440 1999所以编号为1999
				uboot编号由board/esuoyanyu/mini2440/mini2440.c中gd->bd->bi_arch_number=MACH_TYPE_MINI2440决定，打开include/asm-arm/mach-type.h搜索MACH_TYPE_MINI2440发现其为1999，若不一样，则更改编号
			3.uboot文件超过定义的uboot分区大小
				1.在nandflash中对系统组件的安排
					uboot->内核参数->kernel->root
				2.更改uboot分区信息，uboot和内核中对于nand flash的分区必须一致，否则会找不到内核镜像，可以在编译时修改内核分区信息
					uboot分区信息定义在include/config/mini2440.h中，可以修改为适合自己需要的大小
				3，修改系统内核的分区信息，与uboot分区信息保持一致
			4.启动参数的配置
				1.bootcmd uboot自动启动默认参数
					
38.什么需要uboot，不用行不行
	uboot的作用主要是引导内核启动
	理论上是可以的，可以把uboot中所做的一些工作写进内核当中，这样板子也能启动，但是，内核本身就很庞大，大面积修改很难

39uboot的启动过程
	stage1：
		设置异常向量表
		cpu进入svc管理模式
		设置控制寄存器地址
		关闭看门狗
		屏蔽中断
		设置MPLLCON、UPLLCON、CLKDIVN
		关闭MMU、cache
		初始化ram控制寄存机
		复制ubbot第二阶段代码到ram
		设置堆栈
		清除bss段
		跳转到第二阶段代码入口
	stage2
		初始化本阶段使用的硬件设备
		检测系统的内存映射
		将内核加载到内存
	
40为什么栈区的空间不连续 
		

41.进程和线程的区别
	

42uboot如何引导内核启动
	uboot本质：开源的裸机程序，这个裸机程序比较复杂
	bootloader作用：初始化开发板上主要硬件（时钟、内存、硬盘），把操作系统从硬盘拷贝到内存，然后让cpu跳转到内存中区执行操作系统
		boot阶段：
			1.关闭影响cpu正常执行的外设，比如看门狗（到时间后会产生复位信号，导致芯片重启）、中断、mmu、cache
			2.初始化时钟，倍频、分频
			3.初始化内存控制器（ddram）
			4.初始化硬盘，nand flash，从nand flash读数据
		loader阶段：
			1.从硬盘指定的地址加载操作系统kernel到内存指定的地址
			2.跳转到内存中的kernel所在的地址，执行		
		
45.bin文件和elf文件区别
	gcc编译出来的就是elf格式的，直接就可以执行，elf文件里面包含了符号表、汇编等，bin文件是将elf文件中的代码段、数据段，还有自定义的段抽出来做成一个镜像
	bin文件是经过压缩的可执行文件，去掉elf格式的东西，是直接的内存映像的表示。在系统没有加载操作系统的时候可以执行。
	


47.nand flash 和 nor flash区别：
	
48.cpu、MCU、mpu、soc区别
	CPU：一台计算机的运算核心和控制核心。cpu由运算器、寄存机和控制器以及实现他们之间联系的数据、控制及状态的总线构成。CPU的运作原理可分为4个阶段
	MCU：微处理器
	mpu：

51什么是交叉编译
	在一个平台上编译出来的程序，放到别的平台上去运行。
	为什么需要交叉编译环境
		1.嵌入式系统的硬件资源有很多限制，比如CPU主频相对较低，内存容量小，
		2.嵌入式系统MCU体系结构和指令集不同。

52linux系统移植四大部分
	1.搭建交叉编译环境
		含义：在pc机上开发出能够在开发板上运行的程序
	2.bootloader的选择和移植
		为什么系统移植前需要bootloader？
			bootloader的任务就是引导操作系统，即初始化内存后，把内核加载到内存中去运行。
		bootloader分类
			uboot是bootloader的一种，是一种通用引导程序，支持x86、ARM、PoewePC等多种处理器结构
		uboot特点
			开放源码
			支持多个处理器系列
			较高的可靠性和稳定性
			丰富的设备驱动源码
		uboot的目录结构
			*board：目标板相关文件，如SDRAM驱动等
			*common：独立于处理器体系结构的通用代码，如内存大小探测与故障检测
			*cpu：与处理器相关的文件
			*driver：通用设备驱动
			*net：与网络相关的文件目录，如tftp、nfs
			*lib_xxx：处理器体系结相关的文件，如lib_arm包含了arm体系结构相关的文件
			*include：uboot头文件，尤其是configs子目录下与目标板相关的配置文件时移植过程中经常要修改的文件
			*tools：工具，比如交叉编译器
		uboot的工作模式
			启动加载模式：自动将操作系统加载到内核运行
			下载模式：bootloader通过某些通信手段将内核镜像或根文件系统映像等从pc机下载到目标板的内存中运行。
		uboot的启动过程
			stage1：依赖于cpu体系结构的代码，通常用汇编语言实现的（start.s）
				设置异常向量表
				cpu进入svc管理模式
				设置控制寄存器地址
				关闭看门狗
				屏蔽中断
				设置MPLLCON、UPLLCON、CLKDIVN
				关闭MMU、cache
				初始化ram控制寄存机
				复制ubbot第二阶段代码到ram
				设置堆栈
				清除bss段
				跳转到第二阶段代码入口
			stage2
				初始化本阶段使用的硬件设备
				检测系统的内存映射
				将内核从
		开发板 利用nand flash中的bootloader启动流程
			1.开发板上电后，执行irom中的固化代码
			2.irom的程序根据开发板的配置引脚（拨动开关），判断从哪里启动（nand flash）
			3.irom中的程序驱动nand flash
			4.irom中的程序会拷贝nand flash当中的前16K（bootloader前半段）到iram中
			5.iram中的前16k程序初始化sdram内存，然后自拷贝完整的bootloader到内存中并运行，
			6.bootloader拷贝内核到内存，传递kernel的启动参数到内存，设置号r0，r1，r2寄存器的值，最后，CPU跳转到kernel所在内存，先解压缩kernel到内存，再去执行真正的kernel并运行
			7.内核运行起来后，挂载根文件系统，并且运行初始化脚本
		uboot的移植
			1.下载uboot的源码包
			2.解压后添加到我们自己的平台信息（以smdk 100为参考，移植自己s5pc100的开发板）
			3.修改相应目录的文件名，和相应目录的Makefile，指定交叉编译器
			4.编译
			5.针对我们的开发板平台进行移植，主要是修改sdram的运行地址（0x20000000）
			6.开关相应的宏定义
			7.添加nand和网卡的驱动
			8.优化go命令
			9.重新编译 make s5pc100_config（配置我们的开发板），make编译出我们的uboot.bin
			10.设置环境变量，即启动参数，把编译好的uboot下载到内存中运行，过程如下
				1.配置开发板网络：ip地址配置，$setenv ipaddr 192.168.0.6 (配置ip地址到内存的环境变量)，$saveenv(保存环境变量的值到nandflash),在开发板上ping虚拟机
				2.在开发板上，配置tftp服务器（虚拟机）的ip，$setenv serveip 192.168.0.157 
				3.拷贝uboot.bin到/tftpboot(虚拟机的目录)
				4.通过tftp下载uboot.bin到开发板内存
				      tftp 0x20000000 uboot.bin
				5.烧写uboot.bin到nand flash的0地址
				6.切换开发板的启动方式到nand flash（关闭开发板，把sw1的开关4拨动到4那边，启动开发板）
	3.kernel的配置、编译、和移植
		1.将下载好的kerne拷贝到主目录下进行解压
		2.修改顶层Makefile，主要修改平台的体系架构和交叉编译器，比如ARCH=arm, CROSS_PROFILE
		3.拷贝标准配置文件，目的是得到跟我们开发板相关的配置信息   cp arch/arm/configs/s5pc100_deconfig .config，这里拷贝的文件是跟我们平台相关的代码，以为linux支持很多平台，不仅仅是arm
			，所以我们编译的时候只需要编译跟我们平台相关的代码就可以了。具体只需要把相应平台的_deconfig直接拷贝到顶层目录的 .config文件中，这样 .config文件就记录了我们要移植的平台的信息
			因为在配置内核的时候，系统会把所有的配置信息都保存在.config文件中。第一次进行make menuconfig时，系统会根据我们选择的平台信息自选取相关代码和模块，因此我们只要进入然后保存退出
			，选择保存配置信息就可以了，系统会把这些跟我们移植的平台相关的所有配置信息都保存在顶层的.config文件
		4.配置内核
			1.make menuconfig，第一次进入的话，直接保存退出，.这样.config就保存了我们开发平台的信息
			2.linux的内核源码目录下一般都有两个文件：Kconfig和Makefile。分布再各个目录下的Kconfig构成了一个分布式的内核配置数据库，每个Kconfig分别包含了所属目录原文件相关的内核配置菜单，，每个目录都会存放
				功能相对独立的信息，在每个目录中都会存放各个不同的模块信息
			3.在内核配置make menuconfig的时候，系统会自动从Kconfig中读出配置菜单，用户配置完成后，保存到.config中。内核编译的时候，主Makefile调用.config，就知道了用户对内核所有的配置信息。
		5.编译内核
			make zImage，这样在arch/arm/boot目录下就生成了zImage文件，即经压缩的内核镜像
		6.通过tftp网络服务下载测试内核
	4.根文件系统的制作

23:中断
	硬件中断：
		内部中断（不可屏蔽）：内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。
		外部中断（可屏蔽）：计算机外设发出的中断请求，利用中断控制器可以屏蔽这些外部设备的中断请求。
	软件中断：是可以人为控制的，软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序
	
25.内核栈和用户栈
	用户栈：每次进程调用一次函数，都会在用户栈中为该函数分配一个栈帧，存放函数调用过程中产生的局部变量、形参、函数返回值等信息，当函数返回时会释放栈帧
	内核栈：在内核的内存区域中，只有内核能够访问，用来存放进程上下文切换时的进程信息。当进程A要切换到进程B时首先要进入内核，然后内核将CPU中关于进程A的
		进程信息存放在进程A的内核栈中，然后从进程B的内核栈中恢复进程B的的信息到CPU的某些寄存器中，再退出内核模式回到进程B，这样cpu就开始执行进程B

26虚拟内存管理
	分段：
	分页：linux将虚拟内存划分为固定大小的页（4KB），并且以页作为操作系统内存的最小单元，虚拟页---物理页（页框、页帧）
	          地址翻译：完成虚拟页的页号到物理页的页号的对应关系。操作系统为每次进程都维护了一个页表的数据结构，页表的每一项代表（页表项）一个页的映射信息，linux使用多级页表方式维护页表信息
			对于没有分配的页，不去利用页表区维护。使用页目录的数据结构区记录所有页表项（指向页表项的指针），并标记每个页表是否有效，有效才分配空间
	          页翻译：快速地址转换TLB（交给硬件CPU去做），借助CPU 的告诉缓冲区完成，而且使用的是L1级缓存（离CPU核心最近的缓冲）和L2级缓冲，但是虽然cpu的告诉缓存速度快，但与之对应的是缓存空间小
		       当缓冲区满了，就只能通过多级页表读取信息了  ，与此同时，这条翻译信息会缓存到缓冲区，缓冲区会踢掉一条信息，，踢掉最近最少访问的那项（LRU算法）
	补充：内部碎片和外部碎片
		内部碎片：给空间按照固定大小划分成块或者页后，块内或页内没有完全利用导致有一部分空间浪费，这种成为内部碎片，即块内或页内的空间碎片
		外部碎片：因为给空间划分区域后，随着空间的分配和释放，导致空间不连续，
	
	

		
	
		
	
		

		
	
	
		
	
		
	


