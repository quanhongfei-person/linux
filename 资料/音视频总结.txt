IBP 帧：https://www.cnblogs.com/leisure_chn/p/10584910.html

FLV格式：https://www.cnblogs.com/leisure_chn/p/10662941.html

音频编码：https://www.cnblogs.com/leisure_chn/p/10584948.html
视频编码：https://www.cnblogs.com/leisure_chn/p/10584937.html

播放控制：https://www.cnblogs.com/leisure_chn/p/10316225.html

项目框架：https://www.cnblogs.com/leisure_chn/p/10301831.html

基础：https://www.cnblogs.com/leisure_chn/p/10285829.html

GOP是画面组，一个GOP是一组连续的画面。
GOP一般有两个数字，如M=3，N=12。M指定I帧与P帧之间的距离，N指定两个I帧之间的距离。那么现在的GOP结构是：
I BB P BB P BB P BB I

I帧特点:
1)它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;
2)解码时仅用I帧的数据就可重构完整图像;
3)I帧描述了图像背景和运动主体的详情;
4)I帧不需要参考其他画面而生成;
5)I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);
6)I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;
7)I帧不需要考虑运动矢量;
8)I帧所占数据的信息量比较大。


P帧特点:
1)P帧是I帧后面相隔1~2帧的编码帧;
2)P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);
3)解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;
4)P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;
5)P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;
6)由于P帧是参考帧,它可能造成解码错误的扩散;
7)由于是差值传送,P帧的压缩比较高。


B帧特点：
1）B帧是由前面的I或P帧和后面的P帧来进行预测的;
2）B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;
3）B帧是双向预测编码帧;
4）B帧压缩比最高,因为它只反映并参考帧间运动主体的变化情况,预测比较准确;加大B帧的数量可以有效地提高视频数据的压缩比，但是在实时互动的环境下，过多的B帧会引起延时，因为B帧会过分的依赖于前后帧，在网络好的环境下，可以正常的传输帧，这样没有什么问题，但是在网络不好的时候，B帧会等待其他帧到来，会引起延时。
5）B帧不是参考帧,不会造成解码错误的扩散。

注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。

备注：

视频传输中会出现连个比较常见的现象，花屏 和 卡顿

(1)如果在GOP分组中的P帧丢失，会造成解码端的图像发生错误。这就是花屏。GOP一组帧呈现出的连贯效果，由于P帧丢失，它需要更新的部分就没有，所以无法正常呈现。故出现花屏现象。

(2)为了解决花屏的问题发生，我们可以将丢失 P帧 或是 I帧 的 GOP 丢掉（包含其中的所有帧），直到下一个I帧再重新刷新图像。但是由于这一帧丢掉了，所以会出现卡顿。

1. I 帧/P 帧/B 帧
I 帧：I 帧(Intra-coded picture, 帧内编码帧，常称为关键帧)包含一幅完整的图像信息，属于帧内编码图像，不含运动矢量，在解码时不需要参考其他帧图像。因此在 I 帧图像处可以切换频道，而不会导致图像丢失或无法解码。I 帧图像用于阻止误差的累积和扩散。在闭合式 GOP 中，每个 GOP 的第一个帧一定是 I 帧，且当前 GOP 的数据不会参考前后 GOP 的数据。

P 帧：P 帧(Predictive-coded picture, 预测编码图像帧)是帧间编码帧，利用之前的 I 帧或 P 帧进行预测编码。

B 帧：B 帧(Bi-directionally predicted picture, 双向预测编码图像帧)是帧间编码帧，利用之前和(或)之后的 I 帧或 P 帧进行双向预测编码。B 帧不可以作为参考帧。
B 帧具有更高的压缩率，但需要更多的缓冲时间以及更高的 CPU 占用率，因此 B 帧适合本地存储以及视频点播，而不适用对实时性要求较高的直播系统。

2. DTS 和 PTS
DTS(Decoding Time Stamp, 解码时间戳)，表示压缩帧的解码时间。
PTS(Presentation Time Stamp, 显示时间戳)，表示将压缩帧解码后得到的原始帧的显示时间。
音频中 DTS 和 PTS 是相同的。视频中由于 B 帧需要双向预测，B 帧依赖于其前和其后的帧，因此含 B 帧的视频解码顺序与显示顺序不同，即 DTS 与 PTS 不同。当然，不含 B 帧的视频，其 DTS 和 PTS 是相同的。下图以一个开放式 GOP 示意图为例，说明视频流的解码顺序和显示顺序
解码和显示顺序
采集顺序指图像传感器采集原始信号得到图像帧的顺序。
编码顺序指编码器编码后图像帧的顺序。存储到磁盘的本地视频文件中图像帧的顺序与编码顺序相同。
传输顺序指编码后的流在网络中传输过程中图像帧的顺序。
解码顺序指解码器解码图像帧的顺序。
显示顺序指图像帧在显示器上显示的顺序。
采集顺序与显示顺序相同。编码顺序、传输顺序和解码顺序相同。
以图中“B[1]”帧为例进行说明，“B[1]”帧解码时需要参考“I[0]”帧和“P[3]”帧，因此“P[3]”帧必须比“B[1]”帧先解码。这就导致了解码顺序和显示顺序的不一致，后显示的帧需要先解码。

3. FFmpeg 中的时间基与时间戳
3.1 时间基与时间戳的概念
在 FFmpeg 中，时间基(time_base)是时间戳(timestamp)的单位，时间戳值乘以时间基，可以得到实际的时刻值(以秒等为单位)。例如，如果一个视频帧的 dts 是 40，pts 是 160，其 time_base 是 1/1000 秒，那么可以计算出此视频帧的解码时刻是 40 毫秒(40/1000)，显示时刻是 160 毫秒(160/1000)。FFmpeg 中时间戳(pts/dts)的类型是 int64_t 类型，把一个 time_base 看作一个时钟脉冲，则可把 dts/pts 看作时钟脉冲的计数。

3.2 三种时间基 tbr、tbn 和 tbc
不同的封装格式具有不同的时间基。在 FFmpeg 处理音视频过程中的不同阶段，也会采用不同的时间基。
FFmepg 中有三种时间基，命令行中 tbr、tbn 和 tbc 的打印值就是这三种时间基的倒数：
tbn：对应容器中的时间基。值是 AVStream.time_base 的倒数
tbc：对应编解码器中的时间基。值是 AVCodecContext.time_base 的倒数
tbr：从视频流中猜算得到，可能是帧率或场率(帧率的 2 倍)

*Function:掌握ffmpeg中时间戳的知识点。并根据实际的时间来生成ffmpeg内部不同时间基的时间戳

*知识点1：av_q2d(AVRational a)函数
    av_q2d(AVRational);该函数负责把AVRational结构转换成double，通过这个函数可以计算出某一帧在视频中的时间位置
    timestamp(秒) = pts * av_q2d(st->time_base);
    计算视频长度的方法：
    time(秒) = st->duration * av_q2d(st->time_base);

*知识点2：av_rescale_q(int64_t a, AVRational bq, AVRational cq)函数
    这个函数的作用是计算a*bq / cq来把时间戳从一个时间基调整到另外一个时间基。在进行时间基转换的时候，应该首先这个函数，因为它可以避免溢出的情况发生

*知识点3：ffmpeg内部的时间与标准的时间转换方法：
    timestamp(ffmpeg内部的时间戳) = AV_TIME_BASE * time(秒)
    time(秒) = AV_TIME_BASE_Q * timestamp(ffmpeg内部的时间戳)

*知识点4：ts格式文件中3600间隔是什么意思？
    它是25fps帧率的ts媒体文件，每个视频帧的间隔时间。
    ts文件的封装时基是90kHz为单位，timebase是AVRational{1,90000}，简单的理解就是把1秒分成了90000等分，拿25帧率ts文件来分析
    按标准时间来计算每帧的间隔:
    公式为：1 / 25 = 0.04(秒) = 40毫秒
    按ffmpeg中的1秒(即90000)来计算每帧的间隔（单位好像没有明确的定义，暂且使用ffmpeg吧）：
    90000 / 25 = 3600(ffmpeg)
    用时间转换公式可能会更清楚一些：
    1(s) = 90000(ffmpeg)
    40(ms) = 3600(ffmpeg)

*知识点5：不同的时间基
    现实中不同的封装格式，timebase是不一样的。另外，整个转码过程，不同的数据状态对应的时间基也不一致。还是拿mpegts封装格式25fps来
    说（只说视频，音频大致一样，但也略有不同）。非压缩时候的数据（即YUV或者其它），在ffmpeg中对应的结构体为AVFrame,它的时间基为AVRational{1,25}。
    压缩后的数据（对应的结构体为AVPacket）对应的时间基为AVRational{1,90000}





