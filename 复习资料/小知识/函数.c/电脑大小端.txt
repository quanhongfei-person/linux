1、什么是大小端模式？

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，
这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

2、知道大小端有何用？

   首先要介绍一下字节序列，所谓的字节序列就是大于或者等于两个字节类型的数据存放在内存中的顺序（一个字节就不必谈序列!）。
   那么什么时候要用到我们去判断机器是大端模式还是小端模式呢？当我们在跨平台开发或者网络编程的时候就要去关心字节序列了，
   比如说我们用机器A和B通信，如果A和B的端序都是一样的话，中间自然就不用转换来转换去了。
   但是如果A和B机器的端序不一样，如果我们不去做相应的转换，我们传过去的二进制序列就是反的！
1.
#include
int main(int argc, char *argv[])
{
    int i = 0x12345678;
    char c = i;
 
    printf("%x \n", c);
 
    return 0;
}
这种方式的定义一个int型的数据类型，初始化为十六进制0x12345678,
在内存中存放的位置从低位到高位,依次为（低位）87654321（高位）；
再定义一个占一个字节的char型，然后把int型数据赋值给char型数据，
因为char占一个字节，int占四个字节，这样赋值就会丢掉三个字节，
但是这正是我们需要的，如果它打印出78(小端模式)，如果打印出12(大端模式)。

2.
#include
int main(int argc, char *argv[])
{
    int i = 0x12345678;
    char *c = (char *)&i;
 
    printf("%x \n", *c);
 
    return 0;
}
这种方式和上面那种方式差不多，只是运用到了指针的知识，原理都一样

3.
#include
 
typedef union NODE
{
    int i;
    char c;
}Node;
 
int main(int argc, char *argv[])
{
    Node node;
 
    node.i = 0x12345678;
 
    printf("%x\n", node.c);
 
    return 0;
}
这种方式运用到了union(共用体)，所谓的共用体，就是共同使用一块内存，共用体的大小是共用体中的所有类型最大的哪一个，
例如上面的共用体中int是四个字节，char为一个字节，那么这个共用体的大小就是四个字节。
当然这个要看你的系统是多少位的（在这里我说的是32位系统，64位系统int是8个字节），
先对共用体中的int型数据i赋初值，然后在用char去访问一个字节的数据，如果打印出结果为78（小端模式），反之为大端模式。




