01day
面向对象的编程思想： 
	万物皆对象  每个对象都有自己的内存空间
C++语法：
五种方法：
	类：抽象
	对象：实体
	封装：把对象的属性和服务结合成一个独立的系统单位，尽可能的隐蔽对象的内部细节
	继承：特殊类的对象拥有其一般类的全部属性与服务
	多态性：一般类在被特殊类继承后，可以具有不同的数据类型或表现出不同的行为
扩展名：	.cpp/.cc
搭建c++编译环境： Qt
 (1)复制qt-opensource-linux-x86-5.5.1.run
（2）sudo apt-get install build-essential
 (3)sudo apt-get update
 (4)xresurce复制到虚拟机
 (5) xrdb -load  ~/xresurce
数据类型：
bool：一个字节
	true  false
------------------------------------------------------------------------------------------
static_cast    		---->cout << static_cast<double>(n) << endl     (强制类型转换)double多态
const_cast		
dynamic_cast
reinterpret_cast
----------------------------------------------------------------------------------------
头文件：iomianp
setw(10)<<setfill('0')<< n    --->前面补0
标准输入流对象：
	if(cin >> n)	判断用户是否输入正确
引用传参：
	本质上就是一个变量的别名,引用必须初始化，它必须指向一个已存在的对象  	----->int &ref = n;
	引用本身不占内存空间的，引用大多数用在函数传参时
	引用传参时不会产生复制品
	引用不能被拆解，一旦被初始化后，不能另作他用
指针和引用的区别：
	（1）引用必须初始化，指针不用初始化
	（2）没有空引用，但有空指针
返回值是引用的函数：
	不能用一个局部变量作为引用函数的返回值，可以返回staic修饰的变量
	C语言中函数调用表达式不能作为左值，c++中通过引用可以改变函数的返回值
	JAVA中被调函数改主调函数都是用引用
内联函数：
	inline 函数（建议编译器内联）   ------>不用保护现场和恢复现场。在调用该函数时展开在调用出，牺牲空间换时间
注意：内联函数的定义和调用在同一个.c文件中
int add（int a = 0,int b =3,int c = 2） 	----->带有默认形参值的函数
	如果默认形参值有多个，主函数中的实参值是靠左边给的
	默认形参值靠右边定义
	在类中，默认形参值只能放在声明侧
函数的重载：		c++中多态性的一种
	函数的返回值不同不能作为函数的重载，只有函数的参数不同
============================================================================================
02day
类：抽象  对象：具体
基本特点：	
	抽象指对具体问题进行概括，抽出一类对象的公共性质并加以描述的过程
	封装：将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合
	继承：本质上描述多个类之间的关系，一般和特殊的关系（第七章详细介绍）
	多态：函数重载，类型参数化多态，包含性多态（虚函数）（第八章，第九章）
标准成员函数：方法和成员属性
访问权限关键字：	限制的是类的使用者，对类的设计者是无效的
	public:在类外可以访问
	private:在类外不可被访问
	protected:
注：类外只能访问公有成员，不能访问私有的和保护成员，
    用class关键字没有申明访问权限是私有的，类外不能进行访问
    用struct关键字没有访问权限，在类外可以进行访问
类中成员所占的内存空间：
	只是计算类中所定义的成员变量
--------------------------------------------------------
构造函数：c++任何函数都是由构造函数构造而来的
构造函数没有返回值，函数名和类名相同
默认构造函数：Clock（）{}  	 Clock（int h=0,int m = 0,int s = 0）
	      函数不用传参的构造函数叫默认构造函数
	      如果类当中提供构造函数，默认构造函数无效
任何成员函数都可以被重载的
带参构造函数：Clock（int ，int ）{}
int n（10） <====>int n = 10;	本质上调int的带参构造   
初始化列表：Clock(int h,int m,int s):hour(h),minute(m),second(s)
构造函数执行流程：
	第一步，传参；第二步按数据成员的顺序开空间；第三步，执行构造函数函数体。
this指针  （隐藏）
::   作用域标识符
explicit（精确的）: 避免产生歧义
自己试explicit到底加在哪比较合适（声明处还是定义处）
在进行函数参数传递时，c++传引用而不传对象
快捷键：
常引用：const Complex &ref
---------------------------------------------------------------
复制/拷贝构造函数：
	Colck(const Clock  (this指针省略) &ref):hour(ref.hour),minute(ref.minute)
	通过一个已有的对象构造一个新的对象
	传引用而不传对象，传对象会引发函数的递归调用
析构函数：~Clock(){}	先进后出
	任何对象在被销毁时，需要调用析构
析构函数执行流程：
	第一步，执行析构函数函数体；第二步，按构造函数的数据成员的逆顺序销毁空间
-------------------------------------------------------------------------------
类的组合：
	类中数据可以用其他类加以描述
某个类的带参构造，
c语言中的初始化，c++中的初始化要调的带参构造，是在对象名后面加:
CPU cpu；相当于调带参构造
作业：判断两条线相交，分别写两个文件
类和类的关系：
	has -a   组合关系
	is -a    继承关系
UML建模语言：
	（-）减号表示私有的
	（+）加号表示公有的
前向引用说明：当两个类相互引用时，要使用前向引用说明
	对调用类进行声明，但是不能是对象，可以是引用和指针
注： 函数传参时，传对象是基本数据类型，其他自定义的类对象一般传引用
     类中没有数据成员时，sizeof()是1而不是0，用来在内存中占位
============================================================================================
03day
命名空间作用域：
namespace XA{ class TT {}；}  访问：XA :: TT t;
using XA :: TT     后面：TT t；
using namespace XA;   直接对其XA命名空间进行访问
using namespace std;	使用标准命名空间
命名空间允许嵌套使用：
namespace XA { namespace BL { class TTT{};}
XA :: BL :: TTT t;
namespace {};匿名空间作用域里的类其他.cpp无法访问
具有命名空间作用域的变量是全局变量
静态生存期：
c、c++中Static修饰的静态变量的区别：
c语言中是在主函数调用之前空间就被创建
c++中static 修饰的对象，当函数第一次在被调用时，才会被构造出来
如果没被调用，只会被创建，而不会被构造
动态生存期：
	匿名对象具有动态生存期 
AAA（10）：只在它出现的那一行代码中，其他地方无法访问
延长生存周期 ： const AAA &ref = AAA（10）	（注：括号不能被省略）
字符串：
	#include<string>
	string s（）
类的静态成员： static string comename;
特点：	不为本类所特有，而为所有类共有
	类名 :: 变量名		访问静态变量
静态成员函数：static int add{}
类名 :: add（）进行访问		（在没有对象的情况下可以调用）
类的静态成员可以通过：：进行访问，非静态成员函数必须创建对象
注：将.cpp和main.cp分开时,static只能放在函数声明侧
类的静态成员函数无法访问非静态成员函数，类的非静态成员函数既可以调静态函数也可以调非静态成员函数
注：静态成员函数没有对象，没有this指针
二十三种设计模式：
单例模式：
	构造函数，复制构造函数，析构函数都是类的私有成员函数
	（没有用到包含性多态）
友元：	临时打破私有权限的限制
友元函数：	friend 函数
友元类：可以访问其他类的私有和保护成员   friend 类
常对象：
	常对象只能调常成员函数，非常对象既可以调常成员函数，也能调非常成员函数
常成员函数： void fn() const{}
注：静态成员函数不能是常成员函数	
当一个类是常成员，可以构造中初始化列表
第六章
对象数组：
向量：  vector<int> v;
	v.push_back();	//向数组放入
	v.pop_back();	//删除数组的元素
==================================================================================
04day
指针：
	（1）定位；（2）偏移；（3）把看成基类型来看	
const_cast<>()  	去const属性
reinterpret_cast<>()  	强制类型转换
指向类的非静态数据成员的指针：      Clock：：*p  ---> 非静态成员的数据偏移量
.* :成员指针运算符：
	左边是对象，右边是成员指针
->* :成员指向运算符

void （Clock :: *pfn）();
pfn = &Clock :: showTime;

类的静态数据成员：static int count；
int *p = &Clock ;; count
int (*ptr)()
ptr = Clock :: count;
动态内存分配：
new/malloc的区别:
	 (1)malloc 是函数，返回值是void*；new是关键字
	（2）new/delete 会调复制构造和析构函数
当需要new，匿名构造（带参构造）
 申请多个内存空间 	p = new Clock[3];
销毁多个内存空间：	delete [] p;
			p = NULL;
在使用vector容器并不插入对象本身，而是插入对象的指针
	vector<Clock *> v
	v.push_back[new Clock(12,33,21)];
深复制和浅复制：
	浅复制带来的问题：两个对象共用同一块内存空间，析构时析构两次，导致程序崩溃
	默认复制构造函数：浅复制
	把数据成员的整个资源复制过来 ：深复制
sttrcat
erase  清空
empty  判空
第七章		继承与派生
继承：class Base
派生类： class Derived ： public Bsae（单继承）
	派生类是一个特殊的基类
三个特点：
	（1）吸收基类成员（除构造和析构）；（2）改造基类成员（隐藏基类）；（3）添加新的成员
重载和隐藏：
	重载在同一个作用域里面，隐藏不在同一个作用域		
	派生类数据成员同名，基类的数据成员隐藏
protected：
	在派生类能被访问基类修饰的关键字，但在类外不能被访问
private：
	在派生类无法访问基类修饰的关键字的数据成员，类外也不能被访问
 派生方式
|---------------------------------------------------|
|	     public       protected       private   |基类属性
|---------------------------------------------------|
|public      public       protected	不可访问的  |
|---------------------------------------------------|
|protected   protected    protected      不可访问的 |
|---------------------------------------------------|
|private     private      private        不可访问的 |
|---------------------------------------------------|
类型兼容性规则：
	（1）派生类对象可以隐含转换为基类对象；派生类的指针可以隐含转换为基类指针（2）用基类指针指向派生类对象；（基类指针调类的函数，调基类的函数）；	（3）用基类引用派生类对象；
派生类的构造函数执行流程：
（1）传参；（2）按照基类数据成员顺序开辟空间，执行基类构造函数；（3）按照派生类数据成员顺序开辟空间，执行构造函数；
什么情况下必须使用C++的初始化列表
	（1）如果类中有一个成员是一个引用；带参的构造和复制构造函数
	（2）const属性必须给予初始值；
	（3）继承类中调用基类初始化构造函数
析构函数：构造函数的逆过程
多重继承：一个派生函数有多个基类函数
虚继承：消除多重继承带来的多余父本
每多一个virtual多四个字节，减掉一个父本（sizeof题）
虚继承的构造函数执行流程：
（1）有直接或间接虚基类，先构造虚基类，直接或间接构造函数只执行一次
（2执行派生类构造函数
继承：匿名对象；
组合：有对象；
如果分不清类之间的关系，建议一般用组合
第八章：多态
重载多态；强制多态；包含多态；参数多态
运算符重载：operator 
返回值问题：
	引用和对象
返对象还是返引用：
	如果赋值运算符可以放在左值，返引用，否则，返对象；
	必须返回一个引用，但不能放在左边，返常引用；
六个默认函数：
构造；复制构造；析构；赋值重载；取地址运算符重载；取常地址运算符重载
==================================================================================
（c++面向编程语言的核心）虚函数：
virtual
	系统通过实际情况调用函数，包含性多态，动态绑定，                                    
包含性多态：	基类指针指向派生类对象
	两个类必须是继承和派生关系
	基类和派生类的函数同名同参
	基类加virtual关键字
	通过基类指针或者基类引用调用同名同参的函数
覆盖：虚函数    派生类将基类的函数覆盖（不在同一作用域）
sizeof:
	多一个虚函数，多出四个字节，再多，也是四个字节
虚函数实现过程：
指针
虚表(vtab)：本类的虚函数入口地址
静态的虚函数指针数组
	先看函数虚不虚，是虚函数查派生类虚表，否则直接调基类的函数
在含有继承和组合关系：
	先看派生类有没有直接或间接类虚继承
全局函数不能是虚函数
内联函数不能是虚函数（展开，不能跳转）
构造函数不能是虚函数
静态函数不能为虚函数（没有this指针）
析构函数可以为虚函数
纯虚函数： virtual void speak() = 0；类本身就是抽象，无法实例化对象

第九章
函数模板： 一般放在头文件
编译前转换
template <typename T>  算法和数据类型进行脱离
函数优先于调模板
标准模板库
c++11： lamba   []（int n）{ return n;}
STL：
第11章
string （string&& str）noexcept 匿名对象
迭代器：泛化的指针
	算法和数据结构的润滑剂
	左闭右开
string& insert (size_t pos, const string& str)
pos：经过插入操作以后的位置
npos：-1的位置
容器必须具备三个条件：（1）公有的构造函数；（2）公有的运算符重载函数；（3）公有的析构函数；
list：链表  （双向迭代器）
set ：集合  （双向迭代器）
multiset： 多重集合
map：映射	（双向迭代器）
	存放都是键值对    







