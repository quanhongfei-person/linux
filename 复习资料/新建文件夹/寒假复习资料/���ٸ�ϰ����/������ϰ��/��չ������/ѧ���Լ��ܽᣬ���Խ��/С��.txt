fopen....标准IO  对应的是文件流指针 FILE * fp
open.....文件IO  对应文件描述符 int  fd



gets和fgets的区别:
			1.gets是危险的，因为没有规范读
			  到数据的上限
			2.gets会去掉从终端读入的\n字符
			3.fgets会读到n个数据，如果n个
			  数据中存在\n字符则立即停止当
			  前的读取操作
			4.fgets不会去掉从流中读到的\n字
			符
			char buf[1024];
			
			5.fgets(buff, sizeof(buff), stdin);
			  gets(buff);
			  
			  
fgetc EOF 
fgets NULL
while(fgets(buf,1024,src))
{

}
	if(feof(src))
	{
		
	}
	if(ferror(src))
	{
		clearerr(stream);
	}
ferror
	检测一个流是否出错
clearerr
void clearerr(FILE *stream);
	清除一个流出错的标记

if (feof(fp)) {
	printf("到达文件末尾!\n");
} else {
	printf("未到达文件末尾!\n");
}

if (ferror(fp)) {
	printf("出错!\n");
	clearerr(fp);
} else {
	printf("未出错!\n");
}


标准IO之文件定位：
fseek()   ftell()  rewind()

int fseek(FILE *stream, long offset, int whence);
功能：将stream流文件中的文件指针从whence位置开始
      偏移offset字节的长度。
参数：stream  要移动文件指针的目标文件流对象。
	  注意：不支持设备文件，一般用于普通文件。
	  offset  要在文件内偏移的距离，单位字节。
	  		  如果值为整数，则向文件末尾偏移
			  如果值为负数，则向文件开头偏移
	  whence  偏移的起始位置,由系统定义的三个宏开始。
	  	SEEK_SET  文件的开头位置 
		SEEK_CUR  文件的当前位置
		SEEK_END  文件的末尾位置

返回值：	
	成功： 返回 0
	失败：  -1；

如果从文件的指定位置向后偏移过程中已经超过了文件
的当前末尾位置，则会自动以'\0'来填充文件内容，从
而形成一种被称为"空洞文件" 的特殊文件。

rewind()  等效于：fseek(stream,0L,SEEK_SET);

long ftell(FILE *stream);
功能：获取当前文件流指针的具体位置，一般以文件
     开头到当前指针的字节数为返回值。
参数：stream 要返回指针距离的文件流对象
返回值：成功 获取到的距离长度，单位是字节
		失败 -1；


文件定位与文件基本操作的练习：

使用以上标准io的知识点，完成一个大文件的分块写操作。
将多个普通文件，每隔100字节分别写入到一个独立的大
文件中。

./a.out 1.txt 2.txt 3.txt  dst 

dst ===>1.txt的内容 100 空  2.txt 内 100空  3.txt内容。

2.标准IO和文件IO的区别:
		1.标准IO有缓存
		  文件IO没有缓存
		2.标准IO是库函数,在任何操作系统下都能使用
		  文件IO是系统调用,只能在Linux内核中完成操作

		2.行缓存  1K
		  缓存区遇到'\n'刷新
		  与终端建立的缓存都为行缓存
			  1.缓存区满刷新
			  2.遇到'\n'刷新
			  3.使用fflush刷新
			  4.程序结束或者使用fclose刷新
			  stdin
			  stdout
			  
		3.不缓存  0K
		  不进行缓存
		  人机交互、界面控制
		  stderr
标准IO：	 
		程序执行默认打开三个流:
			stdin:标准输入流	从终端读取信息
			stdout:标准输出流	向终端输出信息
			stderr:标准出错流	向终端输出信息
		
		4.setvbuf
		int setvbuf(FILE *stream, char *buf, int mode, size_t size);
		功能:
			修改一个流的缓存类型
		参数:
			stream:文件流指针
			buf:指定的缓存区空间首地址
			mode:	_IONBF	不缓存
					_IOLBF	行缓存
					_IOFBF	全缓存
		返回值:
			成功返回0
			失败返回非0
		
文件IO：
特性：
		.1 没有缓存区
		.2 操作对象不在是流，而是文件描述符
		.3文件描述符
		很小的非负的整数	int   0-1023
		内核每打开一个文件就会获得一个文件	描述符
		
		  每个程序在启动的时候操作系统默认为其打开
		  三个描述符与流对象匹配：
		  0 ==>STDIN_FILENO === stdin
		  1 ==>STDOUT_FILENO == stdout
		  2 ==>STDERR_FILENO == stderr
		  stdin,stdout,stderr,===>FILE*

4.lseek  fseek, rewind ftell
		off_t lseek(int fd, off_t offset, int whence);
		功能:
			定位光标的位置
		参数:
			fd:文件描述符
			offset:偏移量
						正:向后偏移
						负:向前偏移
						零:不偏移
			whence:
				SEEK_SET
				SEEK_CUR
				SEEK_END
		返回值:
			成功返回偏移量
			失败返回-1
			lseek(fd,0,SEEK_END);
	fifo，socket，，，

	
	
	练习：
	使用以上lseek函数测试其功能，并验证是否与fseek一样
	有部分不支持的特性。

	1、不支持O_APPEND的追加模式，无法生成空洞文件。
	2、lseek函数执行失败,文件指针还在偏移前的位置。
	3、lseek函数在设备文件上偏移无效。

	阻塞：程序因为某种条件没有被触发，而导致
	
	'0'   '\0'
面试题：
	文件IO的文件描述符最大值是多少？ ==>1024 个，范围0-1023 《==ulimit -a	
			
			
			fcntl 
			文件控制
			dup,dup2
			文件描述符复制，大多做重定向使用。
 
void sync(void);
功能，只是将所有修改过的块缓冲区排入写队列，就返回。并不等待实际的写入完成。定期（30s，update守护进程完成）会写入

int fsync(int fd);
功能，对单一的文件起作用，并等待写入磁盘。
int fdatasync(int fd);
功能：类似fsync，，除了数据写入外，还会更新文件的相关属性
			
			
fileno      FILE* fp -> int fd
int fileno(FILE *stream);
功能:
	获得一个文件流指针中的文件描述符
参数:
	stream:文件流指针
返回值:
	成功返回文件描述符
	失败返回-1

2.fdopen	int fd -> FILE *fp
 FILE *fdopen(int fd, const char *mode);
 功能:
	将文件描述符转化为文件流指针
 参数:
	fd:已经打开的文件描述符
	mode:
		"r"
		"r+"
		"w"
		"w+"
		"a"
		"a+"
 返回值:
	成功返回文件流指针
	失败返回NULL	

freopen:

FILE *freopen(const char *path, const char *mode, FILE *stream);
功能：将一个已经打开的文件流对象再次以其他文件+mode的方式
      重新打开。

参数：path 要重新打开的文件名称+路径
      mode 要打开的文件方式
	  stream 已经打开的文件流对象。
返回值：成功 新的文件流对象
		失败 NULL；
eg:
	printf("hello \n");
	freopen("./abc","w",stdout); ///输出重定向
	printf("world \n");
	freopen("/dev/tty","w",stdout);  ///还原标准输出

		文件IO 练习：
  用文件IO方式完成任意文件的拷贝。
  
 
 文件IO与标准IO的比较：

文件IO 用于底层设备相关的开发，但是
效率和安全性以及移植性没有标准IO方便。

如果是纯上层开发，优先选择使用标准IO 。



gcc 预编译，
	编译  静态库
	汇编
	link 动态、
	
	
	
GET 方法
请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：
/test/demo_form.asp?name1=value1&name2=value2
有关 GET 请求的其他一些注释：
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据


POST 方法
请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
有关 POST 请求的其他一些注释：
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求

什么是 HTTP？
超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。
HTTP 的工作方式是客户机与服务器之间的请求-应答协议。
web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。
举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。
两种 HTTP 请求方法：GET 和 POST
在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。
GET - 从指定的资源请求数据。
POST - 向指定的资源提交要被处理的数据


 http://www.cnblogs.com/clover-toeic/p/3754433.html   

1)阻塞I/O（blocking I/O）
2)非阻塞I/O （nonblocking I/O）
3) I/O复用(select 和poll) （I/O multiplexing）
4)信号驱动I/O （signal driven I/O (SIGIO)）
5)异步I/O （asynchronous I/O (the POSIX aio_functions)）

前四种都是同步，只有最后一种才是异步IO。
 
 epoll的优点：

1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
      即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。
select、poll、epoll 区别总结：

1、支持一个进程所能打开的最大连接数
select
单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。
poll
poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的
epoll
虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接


2、FD剧增后带来的IO效率问题
select
因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
poll
同上
epoll
因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。

3、 消息传递方式
select
内核需要将消息传递到用户空间，都需要内核拷贝动作
poll
同上
epoll
epoll通过内核和用户空间共享一块内存来实现的。
总结：
综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善 
                                                       

调用函数返回指针或者传入指针，虽然指针确实还指向那片栈区内存空间，但是随着函数结束，那片空间被清空了，里边的内容不得而知，可能是乱码。但是我们可以通过去地址指针传上去，就可以修改指针位置。但是如果动态申请空间的话会造成内存泄漏。


关键字volatile有什么含意? 并给出三个不同的例子。
   【参考答案】一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 
1). 并行设备的硬件寄存器（如：状态寄存器） 
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 
3). 多线程应用中被几个任务共享的变量 

#include  <filename.h>和  #include “filename.h”  有什么区别？
  【标准答案】对于#include  <filename.h>  ，编译器从标准库路径开始搜索 filename.h  ;对于#include  “filename.h”  ，编译器从用户的工作路径开始搜索 filename.h 。


 	31、const  有什么用途？（请至少说明两种）
  【标准答案】： （1）可以定义 const  常量                
（2）const 可以修饰函数的参数、返回值，甚至函数的定义体。被 const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。  


 	32、 static有什么用途？（请至少说明两种）
  【标准答案】                                                                1.限制变量的作用域（static全局变量）；
2.设置变量的存储域（static局部变量）。


 	33、堆栈溢出一般是由什么原因导致的？
  【标准答案；1、没有回收局部变量空间，比如说循环递归调用
	2、由于分配了过大的局部变量空间。

如何引用一个已经定义过的全局变量？
 【标准答案】1、可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
 链接过程实现符 	
 35、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
  【标准答案】可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错
号的重定位。

堆和栈的区别
2）栈内存是由系统分配，系统释放的；以函数为单位进行栈内存分配，函数栈帧，局部变量，形参变量等都存放在栈内存上。堆内存是由用户自己分配的，C语言用malloc/free进行分配释放，C++用new/delete进行分配释放，由于堆需要用户自己管理，因此堆内存很容易造成内存泄露，而栈内存不会。
3）栈的内存分配释放速度快效率高，内存都是连续的；堆内存的分配释放相对于栈来说效率低一些，内存不一定连续，容易产生内存碎片，但是灵活性高。
4）栈是由高地址向低地址扩展的连续内存，栈的大小一般为2M或者10M（大家的redhat系统可以用ulimit -s命令来查看，是10M）；堆是由低地址向高地址扩展的非连续内存，堆的大小影响的因素比较多，和系统虚拟内存的大小有关系。
（1）堆向高内存地址生长，栈向低内存地址生长。
（2）申请后系统的响应：
　　栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。
　　堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。
（3）申请的大小限制不同：
　　栈：在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。
　　堆：堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。
（4）申请的效率不同：
　　栈：栈由系统自动分配，速度快，但是程序员无法控制。
　　堆：堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。
（5）堆和栈的存储内容不同：
　　栈：在函数调用时，先进栈的是函数的各个参数，然后是主调函数中下一条执行指令的地址，最后是主调函数的栈底地址ebp，在大多数的C编译器中，参数是从右往左入栈的。当本次函数调用结束后，局部变量先出栈，然后栈底指针值出栈（赋给ebp）并使ebp指向主函数的栈底，下一条指令的地址值出栈（赋给pc寄存器）并使栈顶指针esp指向主函数的栈顶，最后将各个参数从左到右依次出栈。
堆：一般是在堆得头部用一个字节存放堆得大小，具体内容由程序员安排。
总结
　　数据量较小时，推荐使用栈空间申请，即直接定义数组
　　数据量稍大或者不确定时，推荐使用堆空间内存，即使用malloc或者new动态申请，因为栈空间常常会有大小的限定，当栈空间耗尽时，栈溢出会导致程序崩溃
　　当数据量超大的，建议重新审阅算法或者使用文件存储
　　栈空间与子函数，递归与栈溢出
当一个子函数被调用时，子函数的数据及代码都会被装入栈中，因为栈空间通常会有大小限制，如果子函数太多时，就会有栈溢出的风险。所以当程序员考虑使用递归函数解决问题时，应当考虑到栈溢出的风险。建议学会使用将递归函数写成非递归函数的方法

 	40、带参宏与带参函数的区别(至少说出5点)？
   【标准答案】
	带参宏	带参函数
处理时间	编译时	运行时
参数类型	无	需定义
程序长度	变长	不变
占用存储空间	否	是
运行时间	不占运行时间	调用和返回时占


volatile：表明其所修饰的变量的值可能会在外部改变，在使用这个变量时必须每次都小心的读取这个变量的值，而不是使用保存在寄存器里的备份，在对结构体进行volatile修饰时，表明该结构体或者类当中的所有成员都被视为volatile修饰。		

 	49、什么是预编译，何时需要预编译：
   【标准答案】１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。
			
													   
用两个栈实现一个队列的功能？要求给出算法和思路！
初始化两个空栈AB
将新元素先按顺序压入A，
判断B是否为空
为空将A中元素pop，push进B
popB													   
		
54、在 C++  程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？
【标准答案】C++语言支持函数重载，C 语言不支持函数重载。函数被 C++编译后在库中的名字与 C 语言的不同。假设某个函数的原型为：  void foo(int x, int y); 该函数被 C 编译器编译后在库中的名字为_foo，而 C++编译器则会产生像_foo_int_int 之类的名字。 C++提供了 C 连接交换指定符号 extern“C”来解决名字匹配问题。

68、不能做switch()的参数类型是：
【标准答案】switch的参数不能为实型。

一.算术运算符中的转换规则：
double ←── float 高
↑
long
↑
unsigned
↑
int ←── char,short 低
注意：图中横向箭头表示必须的转换，如两个float型数参加运算，虽然它们类型相同，但仍要先转成double型再进行运算，结果亦为double型。纵向箭头表示当运算符两边的运
算数为不同类型时的转换，如一个long 型数据与一个int型数据一起运算，需要先将int型数据转换为long型， 然后两者再进行运算，结果为long型。所有这些转换都是由系统自动
进行的， 使用时你只需从中了解结果的类型即可。这些转换可以说是自动的。
二.赋值运算符中的转换规则：
在赋值运算中，赋值号两边量的数据类型不同时， 赋值号右边量的类型将转换为左边量的类型。 如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度， 
丢失的部分按四舍五入向前舍入。
注意：常量的默认转换类型：
1.整型常量的默认数据类型是int类型，即有符号整型。
2.浮点数常量的默认类型是double类型，即长浮点数类型。
三.输出时的转换：
在程序中将数据用printf函数以指定格式输出时，当要输出的盐据类型与输出格式不符时，便自动进行类型转换，如一个long型数据用整型格式(%d)输出时，则相当于将long型转
换成整型(int)数据输出；一个字符(char）型数据用整型格式输出时，相当于将char型转换成int型输出。
注意：较长型数据转换成短型数据输出时，其值不能超出短型数据允许的值范围，否则转换时将出错。

		
													   
													   