C语言部分：
文件的7种分类，普通文件，b块文件，c 字符设备文件， d 目录文件， l 链接文件， p 管道文件， s 套接字文件
（1）static关键字作用：
	（1）修饰全局变量;(该变量在本文件中可见，在全局数据区分配内存)
	（2）修饰局部变量；（在全局数据区分配内存，使变量具有静态生存周期）
	（3）修饰函数；（只能在本文件中被使用）
（2）const的作用：
	1)可以保护被修饰的变量，防止意外的修改，增强程序的健壮性（strcpy函数）；
	2）可以节省空间，避免不必要的内存分配；
	3）提高了效率。编译器通常不会为普通const常量分配存储空间，而是将他们保存在符号表中
（3）extern关键字的作用:
	1)可以置于变量前，表示该变量的定义在别的文件中；
	2）置于函数前，表示让函数具有外部链接属性，使其他源文件也可以调用该函数。
（4）volatile作用？为什么要防止优化？
	防止编译器对代码优化（直接读取原始内存地址的值）
	这是因为程序中往往出现很多外在因素。像多线程，中断等。可能会出现变量中的值和寄存器备份后的值不一致。
	使用了volatile这个关键字，编译器在用到这个变量时必须每次都小心的重新读取这个变量的值，而不是使用保存在寄存器的备份。
（5）如何让程序到地址：0x80008000去执行？
 	void （*pt）() = (void (*)())0x80008000（定义函数指针即可）
	int （*s[10])(int)表示函数指针数组，每一个指针指向一个int fun(int param)的函数
（6）do{.....}while(0)的作用是什么？
	如果出现在判断语句过后的宏，这样可以保证宏作为一个整体来实现。

（7）const int *p（指针变量的内容不能被更改）； int* const p（指针变量地址不能被更改）
（8）预处理命令#error的作用？
	当预处理器预处理到#error命令时，编译器将停止编译并输出用户自定义的错误消息
（9）gdb常用的命令
（10）两个字符串最长的公共字串
（11）makefil编写两个.c文件，分别编译和一块编译
	一块编译：
	OBJ = app
	OBJ = main.c add.c
 	$(OBJ):$(OBJS)
		gcc $^ -0 $@
	.PHONY:
	clean:
		rm $(OBJ)
	分别编译：
	CC = gcc
	app：main.c file.c
	mian.o: main.c
	    $(CC) -c -o$@ $<
	file.o:file.c
	    $(CC) -c -o$@ $<
	.PHNOY clean:
		rm -f app main.o file.o
（12）哈希：
――――――――――――――――――――――――――――――――――――――――――――――――
驱动复习：
	禁用中断和禁用arm全局中断

linux版本号，内核

（1）字符设备驱动框架：
	struct cdev
	dev_t num
	主次设备号（major/minor）
	XXX_handle()  //中断函数
		wake_up_interruptible  //唤醒可中断睡眠
	static myopen（）  
		ioremap（）   //物理地址到虚拟地址的映射
	static myclose（）
		iounmap（）
	static myread（）
		copy_to_user（）  //内核到用户空间
		wait_event_interruptible（）  //可中断等待
	static mywrite（）
		copy_from_user（）  //用户到内核空间
	struct file_operations{}//文件操作集合
	static __init()
		（1）MKDEV //制作设备号
		 （2）register_chardev_region //完成设备号到系统的注册
		  （3）cdev_init  //cdev结构体初始化
		  （4）cdev_add   //增加字符设备
		   request_irq  //申请中断
		   wait_init   //初始化等待队列
	static __exit()
		cdev_del
		unregister_chardev_region（）  //释放设备号资源
	module_init()
	module_exit()
	MODULE_LICENSE("GPL")
    混杂设备驱动框架：
	struct miscdev XXX_misc = {
		.minor = MISC_DYNAMIC,
		.name ,
		.fops = &fop,
	}；
	static __init()    misc_register()
	static __exit()    misc_deregister()
	mdev -s
（2）__init作用：函数执行结束后，函数的内存空间会自动释放；
     __exit作用：模块的出口；
（3）设备号组号：主设备号+次设备号  32位设备号（2位方向，8位设备类型，8位指令编号，14位参数大小）
（4）内核到应用：copy_to_usr（从内核到用户空间的数值传递）copy_from_usr（用户到内核的数值传递）
（5）内核中断：request_irq()    所有的外部中断：gpio_to_irq
		每一个中断信号都有一个struct irq_desc结构体
		查看所有中断名：cat /proc/interrupts
		三星提供的中断信号编号：arch/arm/mach-exynos/include/mach/irqs.h
	当中断发生时，Linux会根据中断信号的编号查找中断信息的struct irq_desc结构体进行指定函数调用的（irq_handle_t类型）函数指针位置，进行中断信息的回写
（6）中断方式：	中断顶半部（中断信号的接收）
		中断低半部（中断任务的处理）：tasklet机制，workqueue（工作队列），内核定时器
tasklet：
	任意中断函数执行结束，会自动调用新的函数（时效性更高），不可以长时间延时，调度和睡眠
workqueue（工作队列）内核自动调度，可以睡眠
内核定时器：jiffies 
（7）内核用到的数据结构：双向链表
container_of （根据结构体元素地址，运算得到整个结构体的起始地址）
（8）GOIO的引脚形式：
（1）上拉；（2）下拉；（3）开漏；（4）推挽；（5）浮空；（6）复用推挽；（7）复用开漏；（8）模拟输入；
（9）adc的速率：ADCCON 13-6位 最大转换速率： 1Msps
（10）4412支持4通道10和12位数模转换
ADC的采集参数：（1）模拟信号输入量程：0v--1.8v（2）精度：量程/2的位数次方
（11）加载模块到内核：
静态加载：（1）拷贝代码driver/char
	   (2)修改Makefile在最后一行加上obj-m += test.o
	   (3)kconfig/make menuconfig Y
	   (4)重新编译zImage
动态加载：
	insmod test.ko
两个模块之间如果想进行函数调用或变量表用
则变量和函数必须使用EXPORT_SYMBOL(); 进行标号导出
(12)内核分配函数：
Kmalloc：申请物理空间的连续地址
Vmalloc：申请物理空间的连续地址
（13）plat_form总线模型：
管理设备及驱动而存在   struct platform_driver（驱动） structdevice_platform_device（设备）
（14）arm开发板的启动流程：
	上电之后，iROM代码执行，会拷贝启动前的24K代码到iRAM处执行
	24K = 8k（三重加密校验）+ 16k程序代码
（15）uart:
	4通道的UART  速率：4Mbps
	
（16）iic总线的时序图；
	最多挂载128个器件，支持100k/400k模式        从机：速率（0-400k）  
	写操作：先检查总线是否空闲，主机发送start信号之后，发送7位的从机地址+1位的读写标志位，然后发送从机的寄存器地址和要写入指定位置的数据
	读操作：先将从机地址和从机寄存器写入总线，释放总线，读从机进行读操作，从机就会往指定位置数据发送
（17）bootloader的作用：
	（1）初始化核心器件：SOC，内存，flash，串口，为内核运行做环境准备。
	（2）加载和引导操作系统内核，为操作系统内核运行做环境准备（一小段代码）。
（18）arm异常处理流程：
	CPU做三件事：
	（1）cpu会进行异常分类；
	（2）保存异常发生时PC正在执行指令的下一条指令地址到lr
	（3）跳转到异常向量表固定位置处执行代码；
	中断处理流程：
		（1）保存现场；（2）寻找中断处理入口；（3）中断处理；（4）返回断点
------------------------------------------------------------------------------------------------
高编复习：

（1）线程池：
	多用于服务器（在客户端连接前提前创建好线程）
	先开好线程，全部挂起   同步（信号量）
	在accept之前，
	主线程（管理）
作用：减少了线程的开始回收的时间
（2）多路IO：
	到底用多路IO还是用并行
	单进程
	应用场合：服务器
	select（）：监测各个事件的到来，没有来一直阻塞  最多监测1024，谁阻塞好，先执行那个
	epoll（）：加强版
  区别：（1）select轮询，epoll监听性能不随着监听描述符的增加而增加，是0（1）的，不再是轮询探测事件
	（2）select文件的描述符的限制
	（3）epoll使用共享内存的方式，不在用户和内核之间反复传递监听描述符信息。
（3）http请求报文头：
get 和post区别：
	在请求报文的后面
在安全上：https
	ssl：发送的时候有加密
url :请求时会有所变化
（4）静态库和动态库的区别：
	.a (静态库)：静态库在编译的时候会被直接拷贝一份，复制到目标程序里，缺点会使目标程序的体积增大。
	 .so（动态库）：不需要拷贝到目标程序中，不会影响目标程序的体积，同一份库可以被多个程序使用。动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境，
（5）常用的命令：
	free ：显示内存状态
	ps： 报告程序状态
	top：显示，管理执行中的程序
	ifconfig：显示或设置网络设备
	ping
	netstat
	find
（6）RJ45接口标准：通常用于数据传输，最常见的应用为网卡接口
（7）ETHER V2帧格式（以太网） 目标MAC 源MAC 类型 数据 校验
     PPP（链路层协议）用户实现点对点通讯  PPPOE：经常被用在DSL链接上的变种协议
（8）IP协议帧格式
	首部（20个字节） + 数据部分
  --------------------------------------------------------------
	版本	首部长度	区分服务	总长度（首部+数据）
		标识                       标志     片位移  
	生存时间    协议          		首部检验和
			源地址（4个字节）
			目的地址（4个字节）
		可选字段（长度可变）		填充	
  ------------------------------------------------------------------
（10）TTL
（11）cgi
（9）IP地址的分类和子网掩码的计算
	IP地址，一共分成5类，范围分别如下：
	A类IP：0.0.0.0 ----127.255.255.255
	B类IP：128.0.0.0 ---191.255.255.255
	C类IP：192.0.0.0 ---223.255.255.255
	D类IP：224.0.0.0 ----239.255.255.255
	E类IP：240.0.0.0 ----255.255.255.254
（10）ICMP协议的作用，RIP OSFP作用
	ICMP协议：主要用来检测网络通信故障和实现链路追踪。最典型的应用就是PING和traceroute
	RIP路由协议：动态路由选择协议
	OSFP协议：链路状态路由协议
（11）TCP，UDP的区别？
	（1）基于可靠连接（TCP）与无连接（UDP）；
	（2）TCP点对点连接，UDP可以是一对一，一对多，多对一，多对多的交互连接；
	（3）UDP的首部开销小（8个字节），TCP（20个字节）
	（4）流模式（TCP）与数据报模式（UDP）
	（5）TCP保证数据的正确性，UDP可能丢包；
	（6）TCP保证数据顺序，UDP不保证；
	（7）TCP有拥塞控制，UDP没有拥塞控制
（12）TCP UDP报文帧格式
	数据字段和首部字段
	UDP首部格式（8个字节）：源端口   目的端口  长度（数据报长度） 检验和
	TCP首部格式（20个字节）	端口：分用
	---------------------------------------------------------
			源端口		目的端口
				序号（4个字节）
			       确认号（4个字节）
	数据偏移（4位）   保留    URG（紧急）|ACK|PSH（推送）|SYN（同步）|FIN（终止）     窗口
	检验和					紧急指针
	----------------------------------------------------------
（13）HTTP 协议的作用：
	请描述从打开浏览器访问百度首页到页面显示的整个网络通信过程原理？
（15）进程与线程的区别：
	（1）进程是资源的分配和调度的一个的一个独立单元，线程是最小的执行单元；
	（2）同一个进程中包括多个线程，并且线程共享整个进程的资源，进程之间资源不共享；
	（3）进程创建需要调用fork，线程创建调用pthread_create，进程结束后所有的线程都会销毁，而线程的结束拥有不会影响同个进程中的其他线程的结束
	（4）线程是轻量级进程；
	（5）线程执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
	（6）线程有自己的私有属性TCB，线程ID，寄存器，而进程也有自己的私有属性进程控制PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。
（16）线程间的通信方式：线程同步
	（1）锁机制（互斥锁，条件变量，读写锁）；（2）信号量机制；（3）信号机制；
（17）进程间通信方式：
	（1）管道（无名管道和有名管道）；（2）信号量；（3）消息队列；（4）共享内存；（5）网络主机的进程通信socket；
（18）Linux进程状态：
	用户运行态----内核运行态----就绪态----僵尸态----暂停态----可中断睡眠态-----不可中断睡眠
（19）http默认端口：80；
tcp协议栈：
	应用层（定义数据格式，并按照对应的格式解读数据）；
	传输层（定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序）；
	网络层（定义IP地址，确认主机所在的网络位置，并通过IP地址进行MAC寻址，对外网数据包进行路由转发）；
	物理接口层（对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据）；

网络层：（1）IP协议（前24位是网络地址，后八位是主机地址）；
	（2）ARP协议（地址解析协议，是根据IP地址获取MAC地址的一个网络层协议）；
补充：以太网协议规定，接入网络的设备都必须安装网络适配器，数据包必须从一块网卡传到另一张网卡。网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的MAC地址，MAC地址是每块网卡的身份标识符
	（3）路由协议（ARP的MAC寻址还是局限在同一个子网中，因此网络层引入路由协议，首先通过IP协议来判断两台主机是否在同一个子网中，就通过ARP协议查询对应的MAC地址，然后通过广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由）；
（20）DNS 域名转IP过程：gethostbyname函数

（22）const int *p（指针变量的内容不能被更改）； int* const p（指针变量地址不能被更改）
（23）htons（主机字节序转网络字节序）大小端的关系
（24）TCP服务器的流程：
	（1）创建socket套接字；（2）bind绑定；（3）listen监听；（4）accept接收；（5）recv、send；
（25）三次握手：
	第一次握手：客户端先给服务器发一个SYN包，并进入SYN_SEND状态；
	第二次握手：服务器接到客户端的SYN后，会给客户端发送一个SYN+ACK包，并进入SYN_RECV状态；
	第三次握手：客户端收到服务器的SYN+ACK包后，会给服务器发送一个ACK（确认）
（26）数据库：sqlite；orcale

（28）几种排序算法：（1）冒泡；（2）选择；（3）插入；（4）快排；
（29）一次遍历出现最多的字母；
	算法思想：将字母作为数组的下标，对应的数组的值就是它出现的次数。
（30）判断单向的是否有环：
	算法思想：定义两个快慢指针，若两个指针相遇，则证明有环。
（31）队列与栈的区别：队列先进先出，栈是先进后出
（32）满二叉树：树中除了叶子节点，每个节点都有两个子节点；
	完全二叉树：在满足二叉树的性质后，最后一层的叶子均需在左边
（34）http协议：
  请求报文：
	请求行：get（请求方法） /（URL） HTTP 1.1（协议版本）     
	首部行
	空格
	请求正文
  响应报文：
	状态行： 版本 状态码 短语
	首部行
	空行
	响应正文
	状态码：五大类
		1xx：表示通知信息的
		2xx：表示成功
		3xx：表示重定向
		4xx：表示客户的差错
		5xx：表示服务器的差错

（36）二叉树遍历：前序遍历（根左右）中序遍历（左根右）后序遍历（左右根）
（37）编程实现二叉树多少层？
（38）死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？
	相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态
	（1）系统资源不足、相互竞争资源、请求资源顺序不当；
	（2）互斥、不可抢占、循环等待、请求与保持；
	（3）因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁；
	方法：剥夺资源、杀死其中一个线程