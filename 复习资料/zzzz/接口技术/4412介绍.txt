gnu的汇编规则：
数据定义（Data Definition）伪操作
数据定义伪操作一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪操作有如下几种：
.byte          单字节定义                         .byte     0x12,’a’,23
.short         定义双字节数据			.short    0x1234,65535
.long /.word   定义4字节数据		        .word    0x12345678
.quad          定义8字节			.quad    0x1234567812345678
.float	       定义浮点数			.float     0f3.2
.string/.asciz/.ascii   定义字符串   		.ascii   “abcd\0”,
     注意：.ascii  伪操作定义的字符串需要每行添加结尾字符‘\0‘，其他不需要

val：
	.word 0x11223344
	
val: 
	.word .  (申请一个字的空间将.word的地址写入     .代表当前地址（链接地址）)

（2）汇编控制伪操作
1---相似c语言里的条件编译 #if #endif
.if、.else   .endif伪操作能根据条件的成立与否决定是否执行某个指令序列。
 当.if后面的逻辑表达式为真，则执行.if后的指令序列，否则执行.else后的指令序列；
 .if、.else、.endif伪指令可以嵌套使用。

语法格式：
     .if  logical-expressing
      …
     .else
      …
     .endif
2--macro伪操作可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。
 语法格式：
 .macro   macroname 
 ……..code
 .endm

  .arm         .arm          	    定义一下代码使用ARM指令集编译
  .thumb      .thumb                   定义一下代码使用Thumb指令集编译
  .section    .section     expr	    定义一个段。expr可以使.text   .data.   .bss
  .text        .text {subsection}   将定义符开始的代码编译到代码段
  .data        .data {subsection}   将定义符开始的代码编译到数据段,初始化数据段
  .bss         .bss {subsection}     将变量存放到.bss段,未初始化数据段
  .align        .align{alignment}{,fill}{,max}  通过用零或指定的数据进行填充来使当前位置与指定边界对齐
  .org        .org offset{,expr}    指定从当前地址加上offset开始存放代码，并且从当前地址到当前地址加上offset之间的内存单元，用零或指定的数据进行填充
  
  _start   汇编程序的缺省入口是_start标号,用户也可以在连接脚本文件中用ENTRY标志指明其它入口点.
  .global/ .globl ：用来声明一个全局的符号
  .end       文件结束


   .include 格式：.include “filename”  包含指定的头文件, 可以把一个汇编常量定义放在头文件中

   .equ    格式：.equ    symbol,    expression
   把某一个符号(symbol)定义成某一个值(expression).该指令并不分配空间.(c语言的 #define)


（5）GNU汇编书写格式
     代码行中的注释符号: ‘@’
     语句分离符号: ‘\n’
     直接操作数前缀: ‘#’ 或 ‘$’

     全局标号：地址助记符
     全局标号命名：只能由a～z，A～Z，0～9，“.”，_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成，标号的后面加“：”。


     局部标号:局部标号 主要在局部范围内使用而且局部标号可以重复出现。
     命名：它由两部组成开头是一个0-99直接的数字局部标号 后面加“:  
     F：指示编译器只向前搜索，行号增大的方向
     B：指示编译器只向后搜索，行号减小的方向
     同方向有多个局部标号时，就近跳转。
     
     .S的汇编是没有经过预处理的源文件
     .s的汇编是经过预处理的源文件




嵌入式工程师工作的职责：
使用程序控制soc完成对功能电路的控制。
需要具备的能力：
1.电路图的分析。
2.熟悉功能电路的控制原理。
3.熟悉soc的控制原理。

soc内靠地址定位操作的设备。

物理地址：半导体厂商对地址的线性排布
虚拟地址：cpu寻址的地址都是虚拟地址

ROM  只读内存
RAM  可读写内存
DRAM 动态内存（外接）

4412具有  64k  rom
		  256k RAM
		  可外接dram 3G
		  开发板实际链接ddr内存1G 外接内存地址空间0x40000000-0x80000000

4412的启动流程：
arm规定上电后pc=0
上电后IROM执行，irom的作用判断启动设备，并且从启动设备拷贝24k代码到iram中运行，这些代码是程序员自己完成。24k代码包含两部分：前8k是三星加密校验算法，不开源。后16k程序员自己完成。

u-boot的作用：加载和引导操作系统内核，不属于操作系统内核
1.汇编阶段：初始化cpu、内存，拷贝第二阶段代码到内存，跳转到第二阶段
2.c阶段：初始化本阶段的硬件（网卡、lcd等），加载操作系统内核，引导操作系统内核，向操作系统传递参数


下载程序：
1.在minicom操作：dnw  40008000 （需要使用usb下载程序到0x40008000）
2.在pc操作： dnw  a.out   (将a.out通过dnw传递给开发板)

运行程序：
在minicom操作：go 0x40008000 (将pc指向0x40008000)


gpio通用io引脚：
1.根据开发板的器件找到器件的丝印标号(原理图上器件的名称)。
2.根据丝印标号找器件在原理图上的位置，需要根据电路实际情况分析需要的信号和引脚的功能。
3.根据器件的连线标号找到器件连接在soc的哪个引脚。
4.根据引脚功能找引脚的设置。
芯片手册的操作过程：  GPM4_0 （gpm4组的第0个引脚） ----->芯片手册第六章GPM4CON（设置引脚功能）， GPM4DAT （设置引脚输出的电平 1为高1.8v  0为 0v， 如果设置为输入，则用来反映引脚检测到的电平1为高， 0为低）,寄存器为地址  

汇编程序的编译：
1.arm-linux-gcc -c led.S -o led.o  (只编译不链接)
2.arm-linux-ld -Ttext=0x40008000 led.o -o led （指定text从0x40008000开始链接）
3.arm-linux-objcopy -O binary led led.bin（格式转换）





soc的接口技术：
	接口电路的学习，
嵌入式工程师的职责：
	编写程序，控制功能电路完成特定功能
具备的技能：
1.熟悉接口电路的控制原理
2.熟悉功能电路的工作原理
3.熟悉c
	根据功能电路的需求，控制soc接口电路工作

arm核心通过名字寻址，
soc通过地址控制，通过地址寻找设备
虚拟地址：cpu寻址的地址都是虚拟地址
物理地址：半导体厂商对地址的线性排布

链接地址：程序链接的时候指定起始地址(规划地址)
运行地址：程序开始运行的地址（程序加载地址）

引脚编号、引脚名、引脚作用

tiny4412开发板提供的内存 1G
地址空间 0x40000000 ---- 0x80000000

4412的启动流程： 上电之后pc（arm寄存器）=0

上电后irom的代码执行，会拷贝启动设备的前24k（8k加密校验，16k程序员完成）代码到iram中执行


