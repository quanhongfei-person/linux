中断？？？？
打断cpu当前执行，进行中断处理的过程。

中断的处理流程：
		1.保存断点
		2.寻找中断处理入口
		3.中断处理
		4.返回断点
		
	arm的异常处理机制：
			当异常发发生时，cpu自动跳转到异常向量表固定位置处执行代码
			7种异常
中断信号：
		soc厂商设计特殊电平信号
		外部中断：来自soc之外，通过指定引脚接收信号（触发信号可选择/触发时机不确定）
		内部中断：来自soc内部电路，		触发信号不能更改，触发时机可以预测
	
4412：支持两百多个中断信号，
	（GIC）中断控制器：负责中断信号的接收区分
	
	
	中断基于异常处理
	
	复位      0x0
	未定义    0x4
	软件中断  0x8
	预取中止  0xc
	数据中止  0x10
	空
	irq       0x18
	fiq       0x1c
	
	swi、svc 触发软件中断
	swi #12
	svc #12  linux的系统调用使用软件中断来实现
	
	通过设置协处理器cp15的c12寄存器设置异常向量表基地址
	
	内嵌汇编：在c文件调用汇编语句
	__asm__ __volatile__(
	“mov r0, #3\n”				指令域,所有指令写入“”  以‘\n’结尾
	:"=&r"(ret)           输出变量声明域，完成汇编到c变量数值交互  "=&r"  =变量只写 +变量可读写 r表示变量使用寄存器 &使用寄存器为唯一
	:[num1]"r"(num)       输入变量声明域，完成c变量数值到汇编传递  "r"(num)输入是变量 “i”(100) 
												在汇编中变量使用规则：数输出域和输入域中的小括号  第0个%0  第1个%1
												变量可以使用别名 [num1]"r"(num)  [num1]就是num的别名   应用方式 %[num1]

	:“r0”                     改变声明域,不声明会出现未知错误
	);
	
	
	中断控制器：4412 arm设计的PL390   （gic中断控制器）
	中断控制器，完成中断信号接收区分传递
	160个中断号，在中控制器内部设置，只认中断号，为了对应4核心处理器，pl390设计了
	4个cpu控制接口，每一个cpu控制接口对160个编号中断都有独立控制
	
	中断优先级 0-255
	
	
需求：
		1.中断优先级        ICDIPR_CPU    每一个中断控制接口，对每一个中断信号，都有一个8位域设置优先级
		2.中断使能          ICDISER_CPU   每一个中断控制接口，对每一个中断信号，都有一个使能设置位
		3.电路使能          ICDDCR GIC使能 1使能
		4.选择cpu控制接口   ICCICR_CPUn 1使能cpu控制接口
		5.目标处理器        ICDIPTR_CPU   每一个中断控制接口，对每一个中断信号，都有一个8位域设置目标处理器（0x1 发送给cpu0  0x2 发送给cpu1）
		6.区分    ICCIAR_CPUn  gic会将完成传递的中断信号编号写入
							ICCEOIR_CPUn   将指定编号中断从激活队列清除
			
				ICCPMR_CPUn  cpu控制接口的优先级mask

所有的中断信号：
	中断mask
	中断pending （标志位） 不会自动清除，手动清除
	
	程序完成中断：
			1.中断信号产生
			2.中断信号传递
			3.中断处理
			
			
			
			pwm定时器：
				工作原理  电路按照一个固定的速率对数据进行减法操作，当减为0时，触发中断。
				TINT_CSTAT
				第 0位 定时器0中断使能位
				第 5位 定时器0的中断标志位
				
				
				
		异常发生后cpu的工作流程：
		1.区分异常信号
		2.模式切换
		3.保存返回地址到lr （异常发生时cpu正在执行指令的下一条指令地址）
		4.跳转到异常向量表固定位置执行代码
		
		
		中断处理的标准流程：
		1.保存断点
		2.寻找中断处理入口
		3.中断处理
		4.返回断点
		
		
		中断信号表示一个条件，一次有效，因此必须清除中断标志