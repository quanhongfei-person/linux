gnu的汇编规则：
数据定义（Data Definition）伪操作
数据定义伪操作一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪操作有如下几种：
.byte          单字节定义                         .byte     0x12,’a’,23
.short         定义双字节数据			.short    0x1234,65535
.long /.word   定义4字节数据		        .word    0x12345678
.quad          定义8字节			.quad    0x1234567812345678
.float	       定义浮点数			.float     0f3.2
.string/.asciz/.ascii   定义字符串   		.ascii   “abcd\0”,
     注意：.ascii  伪操作定义的字符串需要每行添加结尾字符‘\0‘，其他不需要

val：
	.word 0x11223344
	
val: 
	.word .  (申请一个字的空间将.word的地址写入     .代表当前地址（链接地址）)

（2）汇编控制伪操作
1---相似c语言里的条件编译 #if #endif
.if、.else   .endif伪操作能根据条件的成立与否决定是否执行某个指令序列。
 当.if后面的逻辑表达式为真，则执行.if后的指令序列，否则执行.else后的指令序列；
 .if、.else、.endif伪指令可以嵌套使用。

语法格式：
     .if  logical-expressing
      …
     .else
      …
     .endif
2--macro伪操作可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。
 语法格式：
 .macro   macroname 
 ……..code
 .endm

  .arm         .arm          	    定义一下代码使用ARM指令集编译
  .thumb      .thumb                   定义一下代码使用Thumb指令集编译
  .section    .section     expr	    定义一个段。expr可以使.text   .data.   .bss
  .text        .text {subsection}   将定义符开始的代码编译到代码段
  .data        .data {subsection}   将定义符开始的代码编译到数据段,初始化数据段
  .bss         .bss {subsection}     将变量存放到.bss段,未初始化数据段
  .align        .align{alignment}{,fill}{,max}  通过用零或指定的数据进行填充来使当前位置与指定边界对齐
  .org        .org offset{,expr}    指定从当前地址加上offset开始存放代码，并且从当前地址到当前地址加上offset之间的内存单元，用零或指定的数据进行填充
  
  _start   汇编程序的缺省入口是_start标号,用户也可以在连接脚本文件中用ENTRY标志指明其它入口点.
  .global/ .globl ：用来声明一个全局的符号
  .end       文件结束


   .include 格式：.include “filename”  包含指定的头文件, 可以把一个汇编常量定义放在头文件中

   .equ    格式：.equ    symbol,    expression
   把某一个符号(symbol)定义成某一个值(expression).该指令并不分配空间.(c语言的 #define)


（5）GNU汇编书写格式
     代码行中的注释符号: ‘@’
     语句分离符号: ‘\n’
     直接操作数前缀: ‘#’ 或 ‘$’

     全局标号：地址助记符
     全局标号命名：只能由a～z，A～Z，0～9，“.”，_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成，标号的后面加“：”。


     局部标号:局部标号 主要在局部范围内使用而且局部标号可以重复出现。
     命名：它由两部组成开头是一个0-99直接的数字局部标号 后面加“:  
     F：指示编译器只向前搜索，行号增大的方向
     B：指示编译器只向后搜索，行号减小的方向
     同方向有多个局部标号时，就近跳转。
     
     .S的汇编是没有经过预处理的源文件
     .s的汇编是经过预处理的源文件

接口？？？（功能电路接口）


4412引脚输出电平  1.8v
									3.3v
									5v
									

4412平台  1G  ddr
					4G emmc
					4412  256K iram
								64k  rom 

IROM
IRAM
DRAM
SRAM
SDRAM

嵌入式软件工程师职责：
			操作电路
			程序编译	
			功能调试
		编写程序，按照功能电路需求，控制soc内部电路进行电信号发送接收
技能：
		熟练c
		熟悉功能电路工作原理
		熟悉soc接口电路工作原理
		
soc控制时，使用地址定位设备

4412开发板的内存地址范围：0x40000000 ---- 0x80000000

4412的启动流程：

		上电后，iROM代码执行，拷贝启动设备前24k到iRAM中执行
		
		24K:8K(加密校验)+16K程序员完成
		16k 初始化时钟、初始化内存、初始化存储、初始化串口、代码拷贝到内存
跳转到内存执行

		
GPIO (通用输入输出引脚)可编程输入输出引脚

gpio通用io引脚：
1.根据开发板的器件找到器件的丝印标号(原理图上器件的名称)。
2.根据丝印标号找器件在原理图上的位置，需要根据电路实际情况分析需要的信号和引脚的功能。
3.根据器件的连线标号找到器件连接在soc的哪个引脚。
4.根据引脚功能找引脚的设置。
芯片手册的操作过程：  GPM4[0] （gpm4组的第0个引脚） ----->芯片手册第六章GPM4CON（设置引脚功能）， GPM4DAT （设置引脚输出的电平 1为高1.8v  0为 0v， 如果设置为输入，则用来反映引脚检测到的电平1为高， 0为低）,寄存器为地址  

汇编程序的编译：
1.arm-linux-gcc -c led.S -o led.o  (只编译不链接)
2.arm-linux-ld -Ttext=0x40008000 led.o -o led （指定text从0x40008000开始链接）
3.arm-linux-objcopy -O binary led led.bin（格式转换）

				下载程序：
1.在minicom操作：dnw  40008000 （需要使用usb下载程序到0x40008000）
2.在pc操作： sudo dnw led.bin    (将led.bin通过dnw传递给开发板)

运行程序：
在minicom操作：go 0x40008000 (将pc指向0x40008000)

			