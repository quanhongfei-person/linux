1.进程的含义?
	进程是一个程序执行的过程，会去分配内存资源，cpu的调度
	
	pcb  是一个结构体，process control block 			print circuit board
	vim -t
	task_struct 
	
	PID,进程标识符
	当前工作路径
	umask
	进程打开的文件列表  文件IO中有提到
	信号相关设置 处理异步io，
	用户id，组id
	进程资源的上限
	ulimit -a，显示资源上限。
2.进程和程序的区别?
	程序:静态
		存储在硬盘中代码，数据的集合
	进程:动态
		程序执行的过程,包括进程的创建、调度、消亡
		.c ----> a.out-----> process(pid)
	1）程序是永存，进程是暂时的
	2）进程有程序状态的变化，程序没有
	3）进程可以并发，程序无并发
	4）进程与进程会存在竞争计算机的资源
	5）一个程序可以运行多次，变成多个进程
		一个进程可以运行一个或多个程序
		内存的分布
	0-3G,是进程的空间，3G-4G是内核的空间,虚拟地址
	虚拟地址 *  物理内存和虚拟内存的地址 映射表 1page=4k


		进程分类：
		1、交互式进程
		2、批处理进程   shell脚本 
		3、 守护进程 
cron 
	进程是操作系统调度的最小单位。
	线程是CPU执行的最小单位。

3.进程的作用?
	while (1) {			while (1) {
		fgets();
	}				}
4.进程的状态：
	3个状态，就绪→执行态→阻塞（等待，睡眠）基本操作系统
	linux中的状态，运行态，睡眠态，僵尸，暂停态。
	
5.进程的调度
	内核主要功能之一就是完成进程调度

	宏观并行
	微观串行

6.查询进程相关命令
	1.ps -ef 

	PID: 进程ID号 内核唯一标识进程的ID号
	PPID:子进程ID号	
	
	2.ps aux

	查看进程相关信息

	1.就绪态、运行态	R
	2.睡眠态、等待态	
		可唤醒等待态	S
		不可唤醒等待态	D
	3.停止态	T
	4.僵尸态	Z
	5.结束态	

	3.top
	根据CPU占用率查看进程相关信息

	4.nice renice设置进程优先级
	
	nice -N CMD
	以N优先级执行CMD
	nice -n 10 ./a.out 
	renice N CMD 
	以N为优先级执行CMD
	renice -n 10 -p 1234

	5.kill和killall杀死一个进程
	kill -9 PID
	杀死PID对应的进程
	kill `pgrep a.out`  
	`,反单引号，在数字1的前面
	"",'',``
	killall -9 进程名
	杀死进程名对应的所有进程
	killall a.out
	6.jobs
	查看后台进程

	进程的前后台调整。
		1、./a.out 默认以前台方式启动程序。
		2、./a.out & 表示将当前进程以后台方式启动。
		3、jobs 可以查看当前终端下的后台程序。
		   jobs -l 查看的时候显示进程的pid号
		   注意：jobs 只针对当前启动进程的终端有效
		4、fg :将后台执行的进程调整到前台执行。
				fg 回车 会将后台任务中带+的调整到前台
				fg xxx 回车 会将任务编号为xxx的调整到前台。

		5、bg： 将前台运行的进程调整到后台执行。
				bg  回车 会将任务中带+ 的任务调整到后台。
				bg xxx 回车将任务编号为xxx的调整到后台。
			 注意：调整前要先将进程挂起，让出控制终端。
			 ctrl+z 挂起当前进程

原语：
1.fork();
	pid_t fork()； 叉子
	一次调用，会返回两次。
	子进程先运行和是父进程先进程，顺序不确定。
	变量不共享。
	子进程复制父进程的0到3g空间和内核中父进程的PCB，但id号不同。
	功能：通过该函数可以从当前进程中克隆一个同名新进程。
		  克隆的进程称为子进程，原有的进程称为 父进程。
		  子进程是父进程的完全拷贝。
		  子进程的执行过程是从fork函数之后执行。
		  
		  子进程与父进程具有相同的代码逻辑。

	返回值：int 类型的数字。
			在父进程中：成功 返回值是子进程的pid号 >0
						失败 返回-1；
			在子进程中：成功 返回值 0
						失败 无

						
	面试题：	
	一次fork生成几个进程？他们之间的关系是什么样的？
	如果两次fork同时前后执行，会生成几个进程？他们之间的
	关系如何表示，有多少个子进程，有没有孙进程？
2.getpid
	pid_t getpid(void);
	功能:
		获得调用该函数进程的pid
	参数:
		缺省
	返回值:
		进程的pid
       
	3.getppid
	pid_t getppid(void);
	功能:
		获得调用该函数进程的父进程pid号
	参数:
		缺省
	返回值:
		返回父进程id号
		fork()&&fork()||fork();
		while(1)sleep(1);
应用场合：
		1）一个进程希望复制自己，使父子进程同时执行不同的代码段。网络服务中会比较多见。
		2）一个进程需要执行一个不同的程序。fork+exec



		使用变量测试，验证位于不同的地址空间。
		文件的写入测试。
	
练习：
	设计一个程序，动态生成两个进程，分别向相同的文件中
	写入不同的数据，要表明是两个进程同时写入的数据。

	./a.out  ===> 1.txt ==>父进程写入的信息 时间+编号(father pid)
	时间+编号(child pid)
	 父进程1123 187 16:02:10
	 子进程1124 188 16:02:15
	
			

作业：
	使用以上知识点，尝试完成如下功能：
	动态生成10个子进程，并打印输出各自进程的pid号。

	
	
	
	
	

	
	